# 爬虫简介

什么是爬虫：
    - 通过编写程序，模拟浏览器上网，然后让其去互联网上抓取数据的过程。

爬虫带来的风险可以体现在如下2方面：
    - 爬虫干扰了被访问网站的正常运营
        - 爬虫抓取了收到法律保护的特定类型的数据或信息

如何在使用编写爬虫的过程中避免进入局子的厄运呢？
    - 时常的优化自己的程序，避免干扰被访问网站的正常运行
    - 在使用，传播爬取到的数据时，审查抓取到的内容，如果发现了涉及到用户隐私
    商业机密等敏感内容需要及时停止爬取或传播


爬虫在使用场景中的分类
    - 通用爬虫：
        抓取系统重要组成部分。抓取的是一整张页面数据。
    - 聚焦爬虫：
        是建立在通用爬虫的基础之上。抓取的是页面中特定的局部内容。
    - 增量式爬虫：
        检测网站中数据更新的情况。只会抓取网站中最新更新出来的数据。

爬虫的矛与盾


反爬机制
    门户网站，可以通过制定相应的策略或者技术手段，防止爬虫程序进行网站数据的爬取。

反反爬策略
    爬虫程序可以通过制定相关的策略或者技术手段，破解门户网站中具备的反爬机制，从而可以获取门户网站中相关的数据。

robots.txt协议：
    君子协议。规定了网站中哪些数据可以被爬虫爬取哪些数据不可以被爬取。

http协议
    - 概念：就是服务器和客户端进行数据交互的一种形式。
常用请求头信息
    - User-Agent：请求载体的身份标识
    - Connection：请求完毕后，是断开连接还是保持连接

常用响应头信息
    - Content-Type：服务器响应回客户端的数据类型

https协议：
    - 安全的超文本传输协议

加密方式

   - 对称秘钥加密
   - 非对称秘钥加密
   - 证书秘钥加密



# requests模块

python中原生的一款基于网络请求的模块，功能非常强大，简单便捷，效率极高。

作用：模拟浏览器发请求。

如何使用：（requests模块的编码流程）

- 指定url
- UA伪装
- 请求参数的处理
- 发起请求
- 获取响应数据
- 持久化存储

## 环境安装

    pip install requests

## 各种请求方式

**get： 请求指定的页面信息，并返回实体主体。**

**head： 只请求页面的首部。**

**post： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。**

**put： 从客户端向服务器传送的数据取代指定的文档的内容。**

**delete： 请求服务器删除指定的页面。**

**get 和 post比较常见 GET请求将提交的数据放置在HTTP请求协议头中；POST提交的数据则放在实体数据中**

```python
import requests
requests.post('http://httpbin.org/post')
requests.put('http://httpbin.org/put')
requests.delete('http://httpbin.org/delete')
requests.head('http://httpbin.org/get')
requests.get('http://httpbin.org/get')
```

## 请求参数

**`url`：网址**

**`params`：get的请求参数，用字典传入**

**`data`：请求参数，用字典传入**

**`headers`：请求头 ，用字典传入  **

`proxies`:**代理使用,`https`的`url`用`https`。`http`的`url`用`http`**

```python
 import requests
 url = 'https://www.sogou.com/'
 param = { 'type': '24', 'interval_id': '100:90', }
 headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) ' }
 proxies={"https":'222.110.147.50:3128'}
 
 response = requests.get(url=url, headers=headers, param = param, proxies=proxies )
```

## 响应对象

**text：把内容以文本字符串输出**

**encoding：编码，有时文本会乱码可以使用**

`Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：`

```python
>>> import requests
>>> r = requests.get('https://api.github.com/events')
>>> r.text
>>> r.encoding = 'utf-8' # 中文乱码时修改成utf-8
```

修改后还是乱码用另一种方法

```python
# name单独的中文提出来转其他码在转成gbk
#通用处理中文乱码的解决方案
name = name.encode('iso-8859-1').decode('gbk')
```



**content： 二进制响应内容，下载文件时直接用这个获取保存**

```python
>>> r.content
b'[{"repository":{"open_issues":0,"url":"https://github.com/...
```

**`jsoh`: `JSON` 响应内容**

`Requests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：如果 JSON 解码失败， r.json() 就会抛出一个异常。例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常需要注意的是，成功调用 r.json() 并**不**意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。`

**raw：原始响应内容**

`在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True。具体你可以这么做：`

```python
>>> r = requests.get('https://api.github.com/events', stream=True)
>>> r.raw
<requests.packages.urllib3.response.HTTPResponse object at 0x101194810>
>>> r.raw.read(10)
'\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\x03'
```



# 数据解析

```
聚焦爬虫:爬取页面中指定的页面内容。
    - 编码流程：
        - 指定url
        - 发起请求
        - 获取响应数据
        - 数据解析
        - 持久化存储
```

 ```python
 数据解析分类：
    - 正则
    - bs4
    - xpath（***）
    
    
 数据解析原理概述：
    - 解析的局部的文本内容都会在标签之间或者标签对应的属性中进行存储
    - 1.进行指定标签的定位
    - 2.标签或者标签对应的属性中存储的数据值进行提取（解析）
 ```



## 正则

**`os.path.exists('./qiutuLibs')`：**判断当前目录下`qiutuLibs`文件夹是否存在

 **`os.mkdir('./qiutuLibs')`**：当前目录下创建`qiutuLibs`文件夹

**常用表达式：**`.*?`代表往下所有到指定位置，`()`内代表取的数据

**`re.findall(ex,page_text,re.S)`**:re正则获取，第一个参数是表达式，第二个是网页文本，第三个固定re.S

### 案例

```python
import requests
import re
import os
# 导入模块
headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko)'}
url = 'https://www.qiushibaike.com/pic/page/%d/?s=5184961'
if not os.path.exists('./qiutuLibs'): 
	os.mkdir('./qiutuLibs')

 page_text = requests.get(url=new_url,headers=headers).text  	# 获取数据

 ex = '<div class="thumb">.*?<img src="(.*?)" alt.*?</div>' 	# 创建一个目正则表达式
    
 img_src_list = re.findall(ex,page_text,re.S)  					# 使用re正则

 for src in img_src_list:  										# 循环所有url

     src = 'https:'+src     									#拼接出一个完整的图片url
  
     img_data = requests.get(url=src,headers=headers).content      #请求到了图片的二进制数据
    
     img_name = src.split('/')[-1]								 #生成图片名称
  
     imgPath = './qiutuLibs/'+img_name 							 #图片存储的路径
     with open(imgPath,'wb') as fp:
         fp.write(img_data)
         print(img_name,'下载成功！！！')
```





## BS4

```python
数据解析的原理：
     1.标签定位
     2.提取标签、标签属性中存储的数据值
        
 bs4数据解析的原理：
    1.实例化一个BeautifulSoup对象，并且将页面源码数据加载到该对象中
    2.通过调用BeautifulSoup对象中相关的属性或者方法进行标签定位和数据提取
```

### 环境安装

  ```python
  pip install bs4
  pip install lxml
  ```

### 实例化`BeautifulSoup`对象

  ```python
 from bs4 import BeautifulSoup
  ```

### 对象的实例化

```python
1.将本地的html文档中的数据加载到该对象中
fp = open('./test.html','r',encoding='utf-8')
soup = BeautifulSoup(fp,'lxml')

2.将互联网上获取的页面源码加载到该对象中
page_text = response.text
soup = BeatifulSoup(page_text,'lxml')
```

### 数据解析的方法和属性

`find` ：对象.div 返回的是文档中第一次出现的标签名对应的标签

`find_all` ：返回符合要求的所有标签（列表）

`select`：标签...选择器,返回的是一个列表。

```python
# soup:实例对象
# 标签查找
soup.div 						 #  对象.div 返回的是文档中第一次出现的标签名对应的标签
soup.find('div') 				  # 等同于soup.div
soup.find_all('div')
    
# 属性定位：
soup.find('div',class_='song') # 第一个参数是标签名，第二个参数 属性名='属性值'class属性要加_

# 选择器
soup.select('.class')              # 类选择器	
soup.select('#id')				  # 选择器

# 层级选择器
soup.select('.tang > ul > li > a')  	# >表示的是一个层级，父子层级
soup.select('.tang > ul a') 		    # 空格表示的多个层级,子孙层级

# 获取标签之间的文本数据
soup.a.text/string/get_text()
text/get_text()                # 可以获取某一个标签中所有的文本内容
string                         # 只可以获取该标签下面直系的文本内容

# 获取标签中属性值
soup.a['href']
```

### 案例

```python
import requests
from bs4 import BeautifulSoup
#需求：爬取三国演义小说所有的章节标题和章节内容http://www.shicimingju.com/book/sanguoyanyi.html
if __name__ == "__main__":
    #对首页的页面数据进行爬取
    headers = {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36'
    }
    url = 'http://www.shicimingju.com/book/sanguoyanyi.html'
    page_text = requests.get(url=url,headers=headers).text

    #在首页中解析出章节的标题和详情页的url
    #1.实例化BeautifulSoup对象，需要将页面源码数据加载到该对象中
    soup = BeautifulSoup(page_text,'lxml')
    #解析章节标题和详情页的url
    li_list = soup.select('.book-mulu > ul > li')
    fp = open('./sanguo.txt','w',encoding='utf-8')
    for li in li_list:
        title = li.a.string
        detail_url = 'http://www.shicimingju.com'+li.a['href']
        #对详情页发起请求，解析出章节内容
        detail_page_text = requests.get(url=detail_url,headers=headers).text
        #解析出详情页中相关的章节内容
        detail_soup = BeautifulSoup(detail_page_text,'lxml')
        div_tag = detail_soup.find('div',class_='chapter_content')
        #解析到了章节的内容
        content = div_tag.text
        fp.write(title+':'+content+'\n')
        print(title,'爬取成功！！！')

```





## xpath

**最常用且最便捷高效的一种解析方式。通用性。**

### xpath解析原理

```
1.实例化一个etree的对象，且需要将被解析的页面源码数据加载到该对象中。
2.调用etree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获。
```

### 环境的安装

```python
pip install lxml
```

### 实例化一个`etree`对象

`etree.parse()`:将本地的`html`文档中的源码数据加载到`etree`对象中

`etree.HTML`:互联网上获取的源码数据加载到该对象中

```python
from lxml import etree

page_text = requests.get(url=url, headers=headers).text # 1.取数据

tree = etree.parse('test.html')                             
tree = etree.HTML(page_text)                                    # 2实例数据
											  # | 可以分割两个表达式 ，取到了所有要的a标签对象列表
a_list = tree.xpath('//div[@class="bottom"]/ul/li/a | //div[@class="bottom"]/ul/div[2]/li/a') # 3 xpath解析
	
```

### `xpath`表达式

```python
# 取标签
/     							# 表示的是从根节点开始定位。表示的是一个层级。
//    							# 表示的是多个层级。可以表示从任意位置开始定位。
//div[@class='song'] 			 # 属性定位：标签[@a属性名="属性值"]
//div[@class="song"]/p[3] 		 # 索引定位：索引是从1开始的。

# 取文本
 /text() 					 # 获取的是标签中直系的文本内容，取当前标签文本
//text() 					 # 标签中非直系的文本内容（所有的文本内容），取子孙标签文本

# 取属性：
/@src     					 #  标签/@属性名
```

### 案例

```python
import requests
from lxml import etree

headers = {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36'
    }
    url = 'https://www.aqistudy.cn/historydata/'
    page_text = requests.get(url=url, headers=headers).text

    tree = etree.HTML(page_text)  					 # 实例化对象网页
   
    # //div[@class="bottom"]/ul/li/          热门城市a标签的层级关系
    # //div[@class="bottom"]/ul/div[2]/li/a  全部城市a标签的层级关系
    # 用|分割两种表达式
    a_list = tree.xpath('//div[@class="bottom"]/ul/li/a | //div[@class="bottom"]/ul/div[2]/li/a') # xpath解析
    all_city_names = []
    
    for a in a_list:                              # 循环获取到的a标签
        city_name = a.xpath('./text()')[0]		  # 循环到a标签下在取文本，相对定位要用./开头
        all_city_names.append(city_name)
    print(all_city_names,len(all_city_names))
```



# 验证码识别

斐斐打码：http://www.fateadm.com/

超级鹰：http://www.chaojiying.com/about.html

```
用户名：lbf1998
邮箱：2669604727@qq.com
密码：dC1~lN1@
```

## 识别验证码类型

```
纯数字：
类型	说明
10100	1位纯数字
10200	2位纯数字
10300	3位纯数字
10400	4位纯数字
10500	5位纯数字
10600	6位纯数字
10700	7位纯数字
10800	8位纯数字
10900	9位纯数字
纯英文：
类型	说明
20100	1位纯英文
20200	2位纯英文
20300	3位纯英文
20400	4位纯英文
20500	5位纯英文
20600	6位纯英文
20700	7位纯英文
20800	8位纯英文
20900	9位纯英文
数字英文：
类型	说明
30100	1位数字英文
30200	2位数字英文
30300	3位数字英文
30400	4位数字英文
30500	5位数字英文
30600	6位数字英文
30700	7位数字英文
30800	8位数字英文
30900	9位数字英文
汉字：
类型	说明
40100	1位汉字
40200	2位汉字
40300	3位汉字
40400	4位汉字
40500	5位汉字
40600	6位汉字
40700	7位汉字
40800	8位汉字
计算题：
类型	说明
50100	简单计算题
50200	复杂计算题
```

## 使用方法

在执行文件内填入对应的用户ip和appip

```python
# coding=utf-8
import os, sys
import hashlib
import time
import json
import requests

FATEA_PRED_URL = "http://pred.fateadm.com"


def LOG(log):
    # 不需要测试时，注释掉日志就可以了
    # print(log)
    log = None


class TmpObj():
    def __init__(self):
        self.value = None


class Rsp():
    def __init__(self):
        self.ret_code = -1
        self.cust_val = 0.0
        self.err_msg = "succ"
        self.pred_rsp = TmpObj()

    def ParseJsonRsp(self, rsp_data):
        if rsp_data is None:
            self.err_msg = "http request failed, get rsp Nil data"
            return
        jrsp = json.loads(rsp_data)
        self.ret_code = int(jrsp["RetCode"])
        self.err_msg = jrsp["ErrMsg"]
        self.request_id = jrsp["RequestId"]
        if self.ret_code == 0:
            rslt_data = jrsp["RspData"]
            if rslt_data is not None and rslt_data != "":
                jrsp_ext = json.loads(rslt_data)
                if "cust_val" in jrsp_ext:
                    data = jrsp_ext["cust_val"]
                    self.cust_val = float(data)
                if "result" in jrsp_ext:
                    data = jrsp_ext["result"]
                    self.pred_rsp.value = data


def CalcSign(pd_id, passwd, timestamp):
    md5 = hashlib.md5()
    md5.update((timestamp + passwd).encode())
    csign = md5.hexdigest()

    md5 = hashlib.md5()
    md5.update((pd_id + timestamp + csign).encode())
    csign = md5.hexdigest()
    return csign


def CalcCardSign(cardid, cardkey, timestamp, passwd):
    md5 = hashlib.md5()
    md5.update(passwd + timestamp + cardid + cardkey)
    return md5.hexdigest()


def HttpRequest(url, body_data, img_data=""):
    rsp = Rsp()
    post_data = body_data
    files = {
        'img_data': ('img_data', img_data)
    }
    header = {
        'User-Agent': 'Mozilla/5.0',
    }
    rsp_data = requests.post(url, post_data, files=files, headers=header)
    rsp.ParseJsonRsp(rsp_data.text)
    return rsp


class FateadmApi():
    # API接口调用类
    # 参数（appID，appKey，pdID，pdKey）
    def __init__(self, app_id, app_key, pd_id, pd_key):
        self.app_id = app_id
        if app_id is None:
            self.app_id = ""
        self.app_key = app_key
        self.pd_id = pd_id
        self.pd_key = pd_key
        self.host = FATEA_PRED_URL

    def SetHost(self, url):
        self.host = url

    #
    # 查询余额
    # 参数：无
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.cust_val：用户余额
    #   rsp.err_msg：异常时返回异常详情
    #
    def QueryBalc(self):
        tm = str(int(time.time()))
        sign = CalcSign(self.pd_id, self.pd_key, tm)
        param = {
            "user_id": self.pd_id,
            "timestamp": tm,
            "sign": sign
        }
        url = self.host + "/api/custval"
        rsp = HttpRequest(url, param)
        if rsp.ret_code == 0:
            LOG("query succ ret: {} cust_val: {} rsp: {} pred: {}".format(rsp.ret_code, rsp.cust_val, rsp.err_msg,
                                                                          rsp.pred_rsp.value))
        else:
            LOG("query failed ret: {} err: {}".format(rsp.ret_code, rsp.err_msg.encode('utf-8')))
        return rsp

    #
    # 查询网络延迟
    # 参数：pred_type:识别类型
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.err_msg： 异常时返回异常详情
    #
    def QueryTTS(self, pred_type):
        tm = str(int(time.time()))
        sign = CalcSign(self.pd_id, self.pd_key, tm)
        param = {
            "user_id": self.pd_id,
            "timestamp": tm,
            "sign": sign,
            "predict_type": pred_type,
        }
        if self.app_id != "":
            #
            asign = CalcSign(self.app_id, self.app_key, tm)
            param["appid"] = self.app_id
            param["asign"] = asign
        url = self.host + "/api/qcrtt"
        rsp = HttpRequest(url, param)
        if rsp.ret_code == 0:
            LOG("query rtt succ ret: {} request_id: {} err: {}".format(rsp.ret_code, rsp.request_id, rsp.err_msg))
        else:
            LOG("predict failed ret: {} err: {}".format(rsp.ret_code, rsp.err_msg.encode('utf-8')))
        return rsp

    #
    # 识别验证码
    # 参数：pred_type:识别类型  img_data:图片的数据
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.request_id：唯一订单号
    #   rsp.pred_rsp.value：识别结果
    #   rsp.err_msg：异常时返回异常详情
    #
    def Predict(self, pred_type, img_data, head_info=""):
        tm = str(int(time.time()))
        sign = CalcSign(self.pd_id, self.pd_key, tm)
        param = {
            "user_id": self.pd_id,
            "timestamp": tm,
            "sign": sign,
            "predict_type": pred_type,
            "up_type": "mt"
        }
        if head_info is not None or head_info != "":
            param["head_info"] = head_info
        if self.app_id != "":
            #
            asign = CalcSign(self.app_id, self.app_key, tm)
            param["appid"] = self.app_id
            param["asign"] = asign
        url = self.host + "/api/capreg"
        files = img_data
        rsp = HttpRequest(url, param, files)
        if rsp.ret_code == 0:
            LOG("predict succ ret: {} request_id: {} pred: {} err: {}".format(rsp.ret_code, rsp.request_id,
                                                                              rsp.pred_rsp.value, rsp.err_msg))
        else:
            LOG("predict failed ret: {} err: {}".format(rsp.ret_code, rsp.err_msg))
            if rsp.ret_code == 4003:
                # lack of money
                LOG("cust_val <= 0 lack of money, please charge immediately")
        return rsp

    #
    # 从文件进行验证码识别
    # 参数：pred_type;识别类型  file_name:文件名
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.request_id：唯一订单号
    #   rsp.pred_rsp.value：识别结果
    #   rsp.err_msg：异常时返回异常详情
    #
    def PredictFromFile(self, pred_type, file_name, head_info=""):
        with open(file_name, "rb") as f:
            data = f.read()
        return self.Predict(pred_type, data, head_info=head_info)

    #
    # 识别失败，进行退款请求
    # 参数：request_id：需要退款的订单号
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.err_msg：异常时返回异常详情
    #
    # 注意:
    #    Predict识别接口，仅在ret_code == 0时才会进行扣款，才需要进行退款请求，否则无需进行退款操作
    # 注意2:
    #   退款仅在正常识别出结果后，无法通过网站验证的情况，请勿非法或者滥用，否则可能进行封号处理
    #
    def Justice(self, request_id):
        if request_id == "":
            #
            return
        tm = str(int(time.time()))
        sign = CalcSign(self.pd_id, self.pd_key, tm)
        param = {
            "user_id": self.pd_id,
            "timestamp": tm,
            "sign": sign,
            "request_id": request_id
        }
        url = self.host + "/api/capjust"
        rsp = HttpRequest(url, param)
        if rsp.ret_code == 0:
            LOG("justice succ ret: {} request_id: {} pred: {} err: {}".format(rsp.ret_code, rsp.request_id,
                                                                              rsp.pred_rsp.value, rsp.err_msg))
        else:
            LOG("justice failed ret: {} err: {}".format(rsp.ret_code, rsp.err_msg.encode('utf-8')))
        return rsp

    #
    # 充值接口
    # 参数：cardid：充值卡号  cardkey：充值卡签名串
    # 返回值：
    #   rsp.ret_code：正常返回0
    #   rsp.err_msg：异常时返回异常详情
    #
    def Charge(self, cardid, cardkey):
        tm = str(int(time.time()))
        sign = CalcSign(self.pd_id, self.pd_key, tm)
        csign = CalcCardSign(cardid, cardkey, tm, self.pd_key)
        param = {
            "user_id": self.pd_id,
            "timestamp": tm,
            "sign": sign,
            'cardid': cardid,
            'csign': csign
        }
        url = self.host + "/api/charge"
        rsp = HttpRequest(url, param)
        if rsp.ret_code == 0:
            LOG("charge succ ret: {} request_id: {} pred: {} err: {}".format(rsp.ret_code, rsp.request_id,
                                                                             rsp.pred_rsp.value, rsp.err_msg))
        else:
            LOG("charge failed ret: {} err: {}".format(rsp.ret_code, rsp.err_msg.encode('utf-8')))
        return rsp

    ##
    # 充值，只返回是否成功
    # 参数：cardid：充值卡号  cardkey：充值卡签名串
    # 返回值： 充值成功时返回0
    ##
    def ExtendCharge(self, cardid, cardkey):
        return self.Charge(cardid, cardkey).ret_code

    ##
    # 调用退款，只返回是否成功
    # 参数： request_id：需要退款的订单号
    # 返回值： 退款成功时返回0
    #
    # 注意:
    #    Predict识别接口，仅在ret_code == 0时才会进行扣款，才需要进行退款请求，否则无需进行退款操作
    # 注意2:
    #   退款仅在正常识别出结果后，无法通过网站验证的情况，请勿非法或者滥用，否则可能进行封号处理
    ##
    def JusticeExtend(self, request_id):
        return self.Justice(request_id).ret_code

    ##
    # 查询余额，只返回余额
    # 参数：无
    # 返回值：rsp.cust_val：余额
    ##
    def QueryBalcExtend(self):
        rsp = self.QueryBalc()
        return rsp.cust_val

    ##
    # 从文件识别验证码，只返回识别结果
    # 参数：pred_type;识别类型  file_name:文件名
    # 返回值： rsp.pred_rsp.value：识别的结果
    ##
    def PredictFromFileExtend(self, pred_type, file_name, head_info=""):
        rsp = self.PredictFromFile(pred_type, file_name, head_info)
        return rsp.pred_rsp.value

    ##
    # 识别接口，只返回识别结果
    # 参数：pred_type:识别类型  img_data:图片的数据
    # 返回值： rsp.pred_rsp.value：识别的结果
    ##
    def PredictExtend(self, pred_type, img_data, head_info=""):
        rsp = self.Predict(pred_type, img_data, head_info)
        return rsp.pred_rsp.value


def TestFunc():
    pd_id = "134935"  # 用户中心页可以查询到pd信息
    pd_key = "K2maDOamVtcO/fcdFOvJ7S147hKeEOGw"
    app_id = "334935"  # 开发者分成用的账号，在开发者中心可以查询到
    app_key = "nAc1Su44jFiCweq7LTAlQFa3k9J9vupJ"
    # 识别类型，
    # 具体类型可以查看官方网站的价格页选择具体的类型，不清楚类型的，可以咨询客服
    pred_type = "30400"
    api = FateadmApi(app_id, app_key, pd_id, pd_key)
    # 查询余额
    balance = api.QueryBalcExtend()  # 直接返余额
    # api.QueryBalc()

    # 通过文件形式识别：
    file_name = "gushiwen.jpg"
    # 多网站类型时，需要增加src_url参数，具体请参考api文档: http://docs.fateadm.com/web/#/1?page_id=6
    
    result =  api.PredictFromFileExtend(pred_type,file_name)   # 直接返回识别结果
    print(result)
    # rsp = api.PredictFromFile(pred_type, file_name)  # 返回详细识别结果

    '''
    # 如果不是通过文件识别，则调用Predict接口：
    # result 			= api.PredictExtend(pred_type,data)   	# 直接返回识别结果
    rsp             = api.Predict(pred_type,data)				# 返回详细的识别结果
    '''

    just_flag = False
    if just_flag:
        if rsp.ret_code == 0:
            # 识别的结果如果与预期不符，可以调用这个接口将预期不符的订单退款
            # 退款仅在正常识别出结果后，无法通过网站验证的情况，请勿非法或者滥用，否则可能进行封号处理
            api.Justice(rsp.request_id)

    # card_id         = "123"
    # card_key        = "123"
    # 充值
    # api.Charge(card_id, card_key)
    # LOG("print in testfunc")


if __name__ == "__main__":
    TestFunc()



```





# session会话

cookie：用来让服务器端记录客户端的相关状态。模拟登录post请求后，由服务器端创建。
**session会话对象作用**

```
1.可以进行请求的发送。
2.如果请求过程中产生了cookie，则该cookie会被自动存储/携带在该session对象中。
```

## session会话使用

```python
创建一个session对象：session = requests.Session()
使用session对象进行模拟登录post请求的发送（cookie就会被存储在session中）
session对象对个人主页对应的get请求进行发送（携带了cookie）
```

```python
import requests

#创建一个session对象
session = requests.Session()

headers = {}
url = ''
data={}

#使用session进行post登陆请求的发送
response = session.post(url=login_url,headers=headers,data=data)

# 之后使用session会一直携带了cookie
text = session.get(url=detail_url,headers=headers).text
```



# 代理

破解封`IP`这种反爬机制。
代理的作用

```
突破自身IP访问的限制。
隐藏自身真实IP
```

## 代理相关的网站

```
 快代理:https://free.kuaidaili.com/free/
 西祠代理
```

## 代理ip的类型

```
 http：应用到http协议对应的url中
 https：应用到https协议对应的url中
```

## 代理ip的匿名度

```
透明：服务器知道该次请求使用了代理，也知道请求对应的真实ip
匿名：知道使用了代理，不知道真实ip
高匿：不知道使用了代理，更不知道真实的ip 	
```

## 示例

```python
import requests
url = 'https://www.baidu.com/s?wd=ip'
headers = {
    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36'
}

page_text = requests.get(url=url,headers=headers,proxies={"https":'222.110.147.50:3128'}).text

with open('ip.html','w',encoding='utf-8') as fp:
    fp.write(page_text)
```



# selenium模块

基于浏览器自动化的一个模块。

## selenium使用流程

### 1 环境安装

```python
pip install selenium
```

### 2 下载一个浏览器的驱动程序（谷歌浏览器）

```python
下载路径：http://chromedriver.storage.googleapis.com/index.html
驱动程序和浏览器的映射关系：http://blog.csdn.net/huilan_same/article/details/51896672
```

### 3 实例化一个浏览器对象

```python
from selenium import webdriver

# 后面是你的浏览器驱动位置
driver = webdriver.Chrome(executable_path='./chromedriver')
```

### 4  编写基于浏览器自动化的操作代码

#### 发起请求:get(url)

```python
driver.get("http://www.baidu.com")
```

#### 定位：find系列的方法

```python
driver.find_element_by_id('nr') 								#id名查找
driver.find_element_by_xpath('//*[@id="nr"]/option[3]').click() # xpath查找并点击
m = driver.find_elements_by_class_name("prefpanelgo")[0] 			#class名查找
```

#### 标签交互输入：send_keys('xxx')

```python
m.send_keys('输入字符串') # 对m对象输入字符串
```

#### 点击：click()

```python
driver.find_element_by_xpath('//*[@id="nr"]/option[3]').click() # xpath查找并点击
```

#### 执行js程序：excute_script('js代码')

```python
driver.execute_script('window.scrollTo(0,document.body.scrollHeight)')
```

#### 前进，后退：back(),forward()

```python
driver.back()
driver.forward()
```

#### 关闭浏览器 quit()

```python
driver.quit()
```

#### 获取浏览器当前页面的页面源码数据

```python
page_text = driver.page_source
```

#### 切换浏览器标签定位的作用域

```
如果定位的标签是存在于iframe标签之中的则必须通过如下操作在进行标签定位
```

```python
# bro浏览器对象
bro.switch_to.frame('iframeResult') #切换浏览器标签定位的作用域
div = bro.find_element_by_id('draggable')  # 切换后在查找
```

#### 动作链

```python
from selenium.webdriver import ActionChains

action = ActionChains(bro)    		# 实例化一个动作链对象
action.click_and_hold（div）			# 长按且点击操作
 
 
action.move_by_offset(17,0).perform() # move_by_offset(x,y):x水平方向 y竖直方向 perform()立即执行动作链操作					
action.release()			# 释放动作链对象
```

#### 可视化界面&规避检测

```python
from selenium import webdriver
#实现无可视化界面
from selenium.webdriver.chrome.options import Options
#实现规避检测
from selenium.webdriver import ChromeOptions

# 实现无可视化界面的操作
chrome_options = Options()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--disable-gpu')

#实现规避检测
option = ChromeOptions()
option.add_experimental_option('excludeSwitches', ['enable-automation'])

#如何实现让selenium规避被检测到的风险
bro = webdriver.Chrome(executable_path='./chromedriver',chrome_options=chrome_options,options=option)

#无可视化界面（无头浏览器） phantomJs
bro.get('https://www.baidu.com')


```





# js逆向

## 把url转成json格式

```python
import json

data = 'aid=629890572&cid=318066735&bvid=BV1Mb4y1X73e&part=1&mid=0&lv=0&ftime=1632399715&stime=1632399715&jsonp=jsonp&type=3&sub_type=0&from_spmid=&auto_continued_play=0&refer_url=&bsource=&spmid='
data_dict = {item.split("=")[0]: item.split("=")[1] for item in data.split("&")}
print(json.dumps(data_dict, indent=4))
```



## JSONP

![image-20210914203918541](爬虫.assets/image-20210914203918541.png)

## AES加密

> Python默认想要进行AES加密，都要通过一个第三方模块。
>
> ```
> pip uninstall crypto
> pip uninstall pycryptodome
> pip install pycryptodome
> 
> ```

基础版本（app逆向）：

逆向的过程中，如果看到的AES，一定要去找：key、iv

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad


def aes_encrypt(data_string):
    key = "fd6b639dbcff0c2a1b03b389ec763c4b"  # 设置key
    iv = "77b07a672d57d64c"					# 设置iv
    aes = AES.new(
        key=key.encode('utf-8'),
        mode=AES.MODE_CBC,
        iv=iv.encode('utf-8')
    )
    raw = pad(data_string.encode('utf-8'), 16)
    return aes.encrypt(raw)


data = "aadzfalskdjf;lkaj;dkjfa;skdjf;akjsdf;kasd;fjaoqwierijhnlakjdhf"   # 加密值
result = aes_encrypt(data)
print(result)
```

变换版本：

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import binascii

KEY = "4E2918885FD98109869D14E0231A0BF4"
KEY = binascii.a2b_hex(KEY)

IV = "16B17E519DDD0CE5B79D7A63A4DD801C"
IV = binascii.a2b_hex(IV)


def aes_encrypt(data_string):
    aes = AES.new(
        key=KEY,
        mode=AES.MODE_CBC,
        iv=IV
    )
    raw = pad(data_string.encode('utf-8'), 16)
    aes_bytes = aes.encrypt(raw)
    return binascii.b2a_hex(aes_bytes).decode().upper()


data = "|878975262|d000035rirv|1631615607|mg3c3b04ba|1.3.5|ktjwlm89_to920weqpg|4330701|https://w.yangshipin.cn/|mozilla/5.0 (macintosh; ||Mozilla|Netscape|MacIntel|"
result = aes_encrypt(data)
print(result)
```





## Python编译JS

 先去安装 `node.js`环境

`node.js`导包方法

```javascript
npm install 模块名 -g   等同于（Python + pip install xxxx)
```

###  `node.js` `编译`

示例1：

```python
import os
import subprocess

os.environ["NODE_PATH"] = "/usr/local/lib/node_modules/"  # 根据自己的操作系统去修改node环境包路径
signature = subprocess.getoutput('node local1.js')
print("结果是--->", signature) 							# 调用的结果就是js执行的结果
```

`local1.js`文件

```js
// 有需要时导入一个第三方包
function func(prev) {
    return prev + 'wupeiqi666'; // 微信：wupeiqi666
}
let data = func("微信：");
console.log(data)
```

示例2：

```python
import os
import subprocess

os.environ["NODE_PATH"] = "/usr/local/lib/node_modules/"     # 根据自己的操作系统去修改node环境包路径
signature = subprocess.getoutput('node local2.js "123" ')  		# "123"会传到process里
print("结果是--->", signature)

```

```javascript
function func(prev) {
    return prev + 'wupeiqi666'
}

let v1 = process.argv[2]   // process,当输入命令时后面的参数会传到这个数组里

let data = func(v1);
console.log(data)
```

注意：参数为了防止断开，可以用引号包裹。



###  `execjs` 编译

`execjs`是Python的模块，方便去执行并编译`JS（node.js）`

```python
import execjs         # 导包
import os

os.environ["NODE_PATH"] = "/usr/local/lib/node_modules/"    # process,当输入命令时后面的参数会传到这个数组里
with open('local.js', mode='r', encoding='utf-8') as f:		# 打开文件
    js = f.read()

JS = execjs.compile(js)                  				

sign = JS.call("func", "微信") # func：js里的函数，后面是实数
print(sign)

```

`local.js`文件

```javascript
// 导入一个第三方包
function func(prev) {
    return prev + 'wupeiqi666'; // 微信：wupeiqi666
}
```



### `编译acrawler.js`

当直接拿到整个逆向的js代码时，可能会编译失败，因为没浏览器环境

直接编译报错，因为缺少浏览器必备环境。

![image-20210925214200528](爬虫.assets/image-20210925214200528.png)

在node.js中补充这个环境，编译应该就能通过了，如何在node.js补充呢？

- jsdom用来补充浏览器环境。

  ```
  下载环境包
  npm install node-gyp@latest sudo npm explore -g npm -- npm i node-gyp@latest
  npm install jsdom -g
  
  # /usr/local/lib/node_modules/
  ```

- 安装 `canvas`（后续编译 `acrawler.js`执行报错，提示加入的）

  ```
  npm install canvas -g
  ```

环境补充好之后，如果你想要让本地编译 `acrawler.js`，接下来你需要 调整 `acrawler.js`代码。【根据jsdom语法 + JS功底】。

```python
import os
import subprocess
import requests

os.environ["NODE_PATH"] = "/usr/local/lib/node_modules/"
# 1.编译（报错：缺少window、document等浏览器必备的环境）
# 2.执行 window.byted_acrawler.sign({url:url})

url = "https://www.toutiao.com/api/pc/list/feed?offset=0&channel_id=3189398957&max_behot_time=0&category=pc_profile_channel"
signature = subprocess.getoutput('node acrawler.js "{}"'.format(url))
signature = signature.strip()

```

`acrawler.js文件`

```javascript
const jsdom = require("jsdom");  // 去安装目录导入jsdom（/usr/local/lib/node_modules/）
const {JSDOM} = jsdom;

// 创建了HTML页面
const dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);

window = dom.window;
document = dom.window.document;



let params = {参数};

Object.assign(global, params);//传入一些参数到global


// 定义了一个函数 _$jsvmprt
global._$jsvmprt = function(b, e, f) {//复制的js的代码
} 


//执行函数
let key = "6d66776e67"; //参数
let arr = [void 0];
global._$jsvmprt(key, arr); // 调用global


// 编写代码，调用 window.byted_acrawler.sign({url:url}) 帮助我们去签名。
// node acrawler.js https://......
var un_sign_url = process.argv[2]
var sign = global.byted_acrawler.sign({url: un_sign_url})
console.log(sign);


```









# app逆向

手机要root

## 抓包工具 charles

### 1 下载并安装

- mac用户

  ```
  访问网址 https://xclient.info/s/charles.html 根据提示下载并破解。
  ```

- windows用户：

  ```
  下载地址：（ charles v4.5.6，大家也可去网上自行下载和破解 ）
  	链接: https://pan.baidu.com/s/1gedTGrFsB1SnNwTvPLoZPg 提取码: cjfe 
  	
  注册码
  	Registered Name:  https://zhile.io
  	License Key:      48891cf209c6d32bf4
  ```

### 2 配置

打开 【Proxy】>【Proxy Settings】设置代理IP端口：

![image-20210928174655348](爬虫.assets/image-20210928174655348.png)



查看本地charles的IP地址：【Help】>【Local IP Address】

![image-20210928174431637](爬虫.assets/image-20210928174431637.png)



模拟器连接 charles代理：填写IP和端口。

![image-20210928174821173](爬虫.assets/image-20210928174821173.png)









默认这样设置charles只能抓http的包，无法抓取Https包，所以需要在手机上安装证书。

设置SSL代理：【Proxy】->【SSL Proxy Settings】

![image-20210928175736813](爬虫.assets/image-20210928175736813.png)



手机上安装证书：

![image-20210928175031248](爬虫.assets/image-20210928175031248.png)

![image-20210928175103171](爬虫.assets/image-20210928175103171.png)

![image-20210928175216018](爬虫.assets/image-20210928175216018.png)

![image-20210928175243620](爬虫.assets/image-20210928175243620.png)



提醒：

- 在模拟器上配置charles，安装证书。
- 在安卓手机上配置charles
  - 手机 android7以下，可以用上面的方法  ----> 受信任的证书。
  - 手机不能用上面的方法（获取root权限）----> 用户级别、系统级别。





安装成功后，就可以在charles中进行抓包了。



案例：链家APP

![image-20210928180354772](爬虫.assets/image-20210928180354772.png)

```python
import requests

res = requests.get(
    url="https://app.api.lianjia.com/Rentplat/v2/house/list",
    params={
        "city_id": "110000",
        "condition": "shahe2%2F",
        "offset": "0",
        "limit": "30",
        "scene": "list",
        "isMyCompany": "0",
        "is_second_filter": "0",
        "request_ts": "1632724797"
    }
)

print(res.json())
```



## 抓包工具 Drony

有些安卓开发在OKHttp设置Proxy.NO_PROXY来屏蔽系统代理。



例如：得物app无法抓到包，无法看到有用数据。

![image-20210928181733546](爬虫.assets/image-20210928181733546.png)









### 1 安装

- Drony-102.apk ，模拟器上可以；手机提示要升级。（英文）

  ```
  链接: https://pan.baidu.com/s/1qvWuuvazhbmJ3x0YdIWvNQ 提取码: g403 
  ```

- Drony-1.3.154.apk，手机上（繁体中文）

  ```
  链接: https://pan.baidu.com/s/1b5iDxb8lmKfn2qzBxxT_kA 提取码: sa09 
  ```

![image-20210928180658045](爬虫.assets/image-20210928180658045.png)





### 2 配置

打开软件，右拉点wifi

<img src="爬虫.assets/image-20220528101225667.png" alt="image-20220528101225667" style="zoom:25%;" />

![image-20210928181213593](爬虫.assets/image-20210928181213593.png)

这里显示wifi信息，点开	

<img src="爬虫.assets/image-20220528101255741.png" alt="image-20220528101255741" style="zoom:25%;" />

<img src="爬虫.assets/image-20210928181247522.png" alt="image-20210928181247522" style="zoom:33%;" />

点开后要配置，第一个代理类型选择手动，ip端口输入抓包工具的ip

<img src="爬虫.assets/image-20220528101351355.png" alt="image-20220528101351355" style="zoom:50%;" />

选择对应的ip端口

<img src="爬虫.assets/image-20220528101420351.png" alt="image-20220528101420351" style="zoom:50%;" />

![image-20210928181331094](爬虫.assets/image-20210928181331094.png)

然后过滤默认值，选中间的引导全部中间的。

<img src="爬虫.assets/image-20220528101620105.png" alt="image-20220528101620105" style="zoom:50%;" />

然后选规则，点+号，在选择对应的app,选择后在点允许所有

![image-20210928181420745](爬虫.assets/image-20210928181420745.png)



![image-20210928181456522](爬虫.assets/image-20210928181456522.png)



![image-20210928181522434](爬虫.assets/image-20210928181522434.png)



![image-20210928181612963](爬虫.assets/image-20210928181612963.png)



## 反编译工具

现在比较好用且方便的反编译工具：JEB、JADX、GDA（win）。（依赖JRE）



### 1 安装JDK

其实此处安装JRE即可，由于后续我们要学习Java开发，直接安装JDK。（JDK中包含JRE）。

```
https://www.oracle.com/java/technologies/downloads/

# 推荐：JDK8（后期工具需要）
https://www.oracle.com/java/technologies/downloads/#java8
```



### 2 jadx

下载地址：链接: https://pan.baidu.com/s/1urJFD5mMp7W1mlH6UAMlJA 提取码: k9p7 

免安装，直接解压并打开即可。

![image-20210928184518710](爬虫.assets/image-20210928184518710.png)



![image-20210928184926023](爬虫.assets/image-20210928184926023.png)



反编译出来之后，就需要根据   关键字、调用关系、Hook（后期讲）的方式找到相关代码。



### 3 jeb

下载：链接: https://pan.baidu.com/s/15JAJBLROsSG4VEsOL8QoMA 提取码: ucv0 



免安装，解压后直接打开：

![image-20210928190459953](爬虫.assets/image-20210928190459953.png)

![image-20210928194245756](爬虫.assets/image-20210928194245756.png)



### 4 GDA

下载：链接: https://pan.baidu.com/s/1sJdUOgiRA9G_2a8oOed12g 提取码: wwaw 

仅支持window版本。





# Java开发基础

- Python，解释型的编程语言。

  ```python
  # hello.py
  
  print("你好呀")
  ```

  ```
  >>>python.exe hello.py
  ```

- Java，编译型&解释型的特定。

  - 学习Java语法，编写Java。
  - 编译 & 解释，环境搭建。

![image-20210929141555448](爬虫.assets/image-20210929141555448.png)











## 1.环境搭建

- **JRE**，（ Java Runtime Envrionment ），Java 运行时环境。

  ```
  含JVM和运行必备的类库。
  
  电脑上想要运行java程序，就必须安装JRE。
  ```

- **JDK**，（ Java Development Kit ），Java开发工具。【包含JRE】【Java开发】

  ```
  含JRE 和 开发必备的工具。
  工具包含：编译工具javac.exe 和 运行工具java.exe
  想要开发Java应用程序，就必须安装JDK。
  ```



接下来，我们就来下载和安装吧。

```
JDK8（jdk 1.8）版本（目前最新已到17）

官方地址：https://www.oracle.com/java/technologies/downloads/#java8
百度云盘：
```

安装好之后需要配置下环境变量。

![image-20210929163956511](爬虫.assets/image-20210929163956511.png)



![image-20210929163410661](爬虫.assets/image-20210929163410661.png)





关于mac系统，自带JDK：

![image-20210929152514354](爬虫.assets/image-20210929152514354.png)



```
/Library/Java/JavaVirtualMachines 
```

![image-20210929152444076](爬虫.assets/image-20210929152444076.png)









JDK安装成功之后就可以编写Java代码并编译 & 运行。

- 编写 Hello.java文件

  ```java
  public class Hello {
      public static void main(String[] args) {
          System.out.println("Hello World");
      }
  }
  ```

- 打开终端编译并运行

  ```
  >>>javac Hello.java
  >>>java Hello
  ```

  ![image-20210929152955231](爬虫.assets/image-20210929152955231.png)





编写代码建议大家使用IDE（集成开发环境）来提供开发效率。

- 下载 2020.1 版本。  https://www.jetbrains.com/idea/

- 激活：https://www.zhihu.com/zvideo/1254435808801050624

  ```
  工具见课后 代码和笔记。
  ```



-------------------------

以上就是环境搭建。





## 2.初识Java

代码的初步分析： Hello.java

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

- 文件名

  ```
  一个文件中最多只能有一个public类，文件名需要与此public类一致。
  如果文件中有多个类，文件名与public类名一致。
  如果文件中有多个类 且 无public类，文件名可与任意类名一致。
  ```

- 类名

  ```
  一般首字母大写，例如：Hello、UserInfo
  ```

- 类修饰符：public、（不写）default

  ```java
  // public，表示此类可以被任意类调用，例如：
  src
  ├── Hello.java
  └── utils
      └── Request.java
  
  
  // Request.Java文件
  package utils;
  
  public class Request {
      public void show(){
          System.out.println("哈哈哈哈哈");
      }
  }
  
  
  // Hello.java文件
  import utils.Request;
  
  public class Hello {
      // 程序入口
      public static void main(String[] args) {
          // 根据类创建了一个对象
          Request req = new Request();
          // 对象.show()
          req.show();
      }
  }
  ```

  ```java
  // default，表示此类只能在当前包被调用，例如：
  src
  ├── Hello.java
  └── utils
      ├── Helper.java
      └── Request.java
  
  // Request.Java文件
  package utils;
  class Request {
      public void show(){
          System.out.println("哈哈哈哈哈");
      }
  }
  
  // Helper.java文件
  package utils;
  import utils.Request;
  public class Helper {
      public void doAction(){
          Request req = new Request();
          req.show();
      }
  }
  
  // Hello.java文件
  import utils.Helper;
  public class Hello {
      public static void main(String[] args) {
          Helper req = new Helper();
          req.doAction();
      }
  }
  ```

- 类成员修饰符：public、private、protected、default（大前提：要先就有访问类的权限）

  - public，只要有权访问类，在任意情况下都可以调用。

  - private，只允许自己类调用，在其他类中无法调用到。

    ```java
    class Other {
        private static void doSomething() {
            System.out.println("DoSomething");
        }
    
        public static void doing() {
            System.out.println("doing");
            doSomething();
        }
    }
    
    public class Hello {
    
        private static void show() {
            System.out.println("show");
        }
    
        public static void main(String[] args) {
            show(); // 可以
            // Other.doSomething(); // 不可以
            Other.doing(); // 可以
        }
    }
    ```

  - protected，对同一包内的类和所有**子类可见（不是同一个包）**。

    ```java
    package utils;
    
    public class Helper {
    
        protected void doIt(){
        }
        
        void doAction(){
        }
    }
    ```

    ```java
    package xx;
    import utils.Helper;
    
    public class Db extends Helper {
        public void exec(){
            doIt(); // 可以访问
            // doAction(); 无法访问
        }
    }
    ```

  - default，在同一包内可见。

- 静态成员，无序实例化直接通过类就能调用。

  ```java
  class Person {
      /**
       * 静态方法
       */
      public static void f1() {
          System.out.println("f1");
      }
  
  
      public String name;
      public Integer age;
  
      /**
       * 构造方法
       *
       * @param n1 姓名
       * @param n2 年龄
       */
      public Person(String n1, int n2) {
          this.name = n1;
          this.age = n2;
      }
  
      /**
       * 实例方法
       */
      public void f2() {
          System.out.println("f2" + this.name);
      }
  
  }
  
  public class Hello {
  
      public static void main(String[] args) {
          Person.f1();
  
          Person p1 = new Person("武沛齐", 999);
          p1.f2();
      }
  }
  ```

- 返回值，方法有返回值就必须要在定义是指定。

  ```java
  class Person {
  	
      // void，无返回值。
      public static void f1() {
          System.out.println("f1");
      }
  
      // 字符串类型返回值
      public static String f2() {
          return "哈哈哈哈";
      }
      
      public static int f3() {
          return 12;
      }
  
  }
  
  public class Hello {
  
      public static void main(String[] args) {
          Person.f1();
  
          String res = Person.f2();
      }
  }
  
  ```

- 参数，Java中传参时需要指定类型和形参。

  ```java
  class Person {
  
      public static void f1(String name,int age) {
          System.out.println("f1");
      }
  
  }
  
  public class Hello {
  
      public static void main(String[] args) {
          Person.f1("武沛齐",888);
      }
  }
  ```

  

## 3.注释

```java
/**
 * 类的注释
 * 类的注释
 */
public class Hello {

    /**
     * 方法的注释
     * @param args 参数...
     */
    public static void main(String[] args) {
        // 1.单行注释
        
        /*
        2.多行注释
        多行注释
         */
    }
}
```



## 4.变量

Java中定义变量的格式：`变量类型 变量名 = 值;`

```java
public class Hello {

    public static void main(String[] args) {
        String name = "武沛齐";
        int age = 18;
        String firstName = "xxx"; // python first_name

        String email;
        email = "wupeiqi@live.com";

        String hobby = null;
        hobby = "玩游戏";
    }
}
```



## 6.输入和输出

```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {

        // 输入
        Scanner input = new Scanner(System.in);
        System.out.print("用户：");
        String name = input.nextLine();
        
        System.out.print("年龄：");
        int age = input.nextInt(); // 将输入的内容转化弄成int类型
        
        String message = String.format("姓名：%s，年龄:%d",name,age);
        System.out.println(message);
    }
}
```

```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("用户：");
        String name = input.nextLine();

        System.out.print("密码：");
        String pwd = input.nextLine();

        // name.equals("武沛齐") && pwd.equals("123")
        if (name == "武沛齐" && pwd == "123") {
            System.out.println("登录成功");
        } else {
            System.out.println("登录失败");
        }

    }
}
```



## 5.条件语句

```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("请输入年龄：");
        int age = input.nextInt();
        
        if (age < 18) {
            System.out.println("少年");
        } else if (age < 40) {
            System.out.println("大叔");
        } else {
            System.out.println("老汉");
        }
    }
}
```



```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("请输入序号：");
        int num = input.nextInt(); // 任意数字

        switch (num) {
            case 1:
                System.out.println("话费查询");
                break;
            case 2:
                System.out.println("电话预约");
                if (1 == 1) {
                    System.out.println("哈哈哈哈");
                }
                break;
            default:
                System.out.println("输入错误");
                break;
        }
    }
}
```







## 6.循环语句

while

```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {
        int count = 0;
        while (count < 3) {
            Scanner input = new Scanner(System.in);
            System.out.print("用户：");
            String name = input.nextLine();

            System.out.print("密码：");
            String pwd = input.nextLine();

            // name == "武沛齐" && pwd == "123"
            if (name.equals("武沛齐") && pwd.equals("123")) {
                System.out.println("登录成功");
                break;
            } else {
                System.out.println("登录失败");
            }
            count += 1;
        }

    }
}
```



do while

```java
import java.util.Scanner;

public class Hello {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print("请输入序号：");
        int num = input.nextInt();

        do {
            System.out.println("符合规范");
        } while (num < 3);
    }
}
```







for循环

```java
public class Hello {

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            System.out.println(i); // continue/break
        }
    }
}
```



```java
public class Hello {

    public static void main(String[] args) {

        String[] dataArray = {"武沛齐", "Alex", "日天", "张开"}; // 列表
        for (String item : dataArray) {
            System.out.println(item);
        }
        for(int i=0;i<dataArray.length;i++){
            String item = dataArray[i];
            System.out.println(item);
        }
    }
}
```



注意：循环中也可以使用break和continue关键字（与Python中的功能相同）。



## 7. 数据类型相关



### 7.1 整数类型

- byte，字节		  【1字节】表示范围：-128 ~ 127 即：`-2^7 ~ 2^7 -1  `  
- short，短整型    【2字节】表示范围：-32768 ~ 32767
- int，整型             【4字节】表示范围：-2147483648 ~ 2147483647
- long，长整型      【8字节】表示范围：-9223372036854775808 ~ 9223372036854775807

```java
public class Hello {

    public static void main(String[] args) {
        byte v1 = 32;
        short v2 = 10000;
        int v3 = 22221331;
        long v4 = 554534353424L;
    }
}
```

```java
public class Hello {

    public static void main(String[] args) {

        short v1 = 32;

        // 强制类型转换
        int v2 = (int)v1;
        System.out.println(v2);
    }
}
```



**特别提醒**：在逆向时经常会看到byte数组表示字符串。

```java
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
        // byte数组，每个元素都是一个字节 [11,22,33,44,55]
        byte[] data = {97, 105, 100, 61, 50, 52, 54, 51, 56, 55, 53, 55, 49, 38, 97, 117, 116, 111, 95, 112, 108, 97, 121, 61, 48, 38, 99, 105, 100, 61, 50, 56, 57, 48, 48, 56, 52, 52, 49, 38, 100, 105, 100, 61, 75, 82, 69, 104, 69, 83, 77, 85, 74, 104, 56, 116, 70, 67, 69, 86, 97, 82, 86, 112, 69, 50, 116, 97, 80, 81, 107, 55, 87, 67, 104, 67, 74, 103, 38, 101, 112, 105, 100, 61, 48, 38, 102, 116, 105, 109, 101, 61, 49, 54, 50, 55, 49, 48, 48, 57, 51, 55, 38, 108, 118, 61, 48, 38, 109, 105, 100, 61, 48, 38, 112, 97, 114, 116, 61, 49, 38, 115, 105, 100, 61, 48, 38, 115, 116, 105, 109, 101, 61, 49, 54, 50, 55, 49, 48, 52, 51, 55, 50, 38, 115, 117, 98, 95, 116, 121, 112, 101, 61, 48, 38, 116, 121, 112, 101, 61, 51}; // 这里应该表示的是一个字符串。

        String dataString = new String(data);
        System.out.println("字节数组转换为字符串：" + dataString);

        
        
        // 字符串也可以转换成字节
        byte[] res = dataString.getBytes();
        System.out.println(Arrays.toString(res));

        try{
            String name = "武沛齐";
            // v1 = [-50, -28, -59, -26, -58, -21] Java中
            // v2 = [206, 228, 197, 230, 198, 235] Python中
            byte[] v1 = name.getBytes("GBK");
            System.out.println(Arrays.toString(v1));

            byte[] v2 = name.getBytes("UTF-8"); // 默认
            System.out.println(Arrays.toString(v2));
        }catch (Exception e){

        }
    }
}
```

```python
# Python脚本，方便你们以后使用。
byte_list = [-50, -28, -59, -26, -58, -21]

bs = bytearray() # python字节数组
for item in byte_list:
    if item < 0:
        item = item + 256
    bs.append(item)
str_data = bs.decode('gbk')  # data = bytes(bs)
print(str_data)
```



**进制转换**：在java中除了十进制以外，其他的进制都是用字符串来表示。

```java
public class Hello {

    public static void main(String[] args) {
        // 十进制转其他
        int n = 18;
        
        String v2 = Integer.toBinaryString(n); // 二进制，字符串形式
        String v8 = Integer.toOctalString(n);
        String v16 = Integer.toHexString(n);
        String v3 = Integer.toString(n,3);
        
        String dataStr = Integer.toString(n); // "18"
        
        // 其他转十进制
        String data = "10010";
        int v10 = Integer.parseInt(data,2);
        
        // 其实：Integer.toString 和 Integer.parseInt 其实就是整型和字符串之间的转换。
    }
}
```





















### 7.2 字符

```java
char v1 = '武'; // 字符
String v2 = "武沛齐"; // 字符串
```





字符，char		【2字节】对应的是unicode中的码点，用于存储单个字符。

```java
public class Hello {

    public static void main(String[] args) {
        String text = "alex是个大傻B";

        char v1 = text.charAt(1);
        System.out.println(v1); // l

        char v2 = text.charAt(2);
        System.out.println(v2); // e

        char v3 = '中'; // 单引号
        System.out.println(v3);

        char v4 = 'A'; // 单引号   65
        char v5 = '#'; // 单引号   35
        
        int v6 = v4 + v5; // 十进制 100
        System.out.println(v6); //100

        char v7 = (char)v6;
        System.out.println(v7); // d
    }
}
```









### 7.3 字符串

```java
import java.io.UnsupportedEncodingException;

public class Hello {

    public static void main(String[] args) throws UnsupportedEncodingException {
        String v1 = "武沛齐";
        String v2 = new String("武沛齐");

        // char[] data = new char[]{'武', '沛', '齐'};
        // char[] data = {'武', '沛', '齐'};
        // String v3 = new String(data);
        String v3 = new String(new char[]{'武', '沛', '齐'});

        String v4 = new String(new byte[]{-26, -83, -90, -26, -78, -101, -23, -67, -112});
        String v5 = new String(new byte[]{-50, -28, -59, -26, -58, -21},"GBK");
		
        // 上面都是不可变  "alex" + "SB" + "xx" + "xxxx"
        // 可变字符串 "name=wupeiqi"
        StringBuilder sb = new StringBuilder(); 
        sb.append("name");
        sb.append("=");
        sb.append("wupeiqi");
        sb.append("&");
        sb.append("age=");
        sb.append("999");
        // String v6 = sb.toString(); //name=wupeqi&age=999
        String v6 = new String(sb);

        StringBuffer strBuffer = new StringBuffer(); // 线程安全（多线程）
        strBuffer.append("name");
        strBuffer.append("=");
        strBuffer.append("wupeiqi");
        strBuffer.append("&");
        strBuffer.append("age=");
        strBuffer.append("999");
        // String v6 = strBuffer.toString();
        String v7 = new String(strBuffer);


        
        // 其他类型的方法执行，直接返回一个字符串
        String v8 = Integer.toString(123123);
        String v9 = Double.toString(3.14);
        
        // 或这
        String v10 = String.valueOf(123);
    }
}
```



对于字符串，内部提供了很多方便的方法对他进行操作，例如：

```java
public class Hello {

    public static void main(String[] args) {
        String origin = "alex是个大DB";

        char v1 = origin.charAt(5); // 指定字符
        int len = origin.length();  // 长度
        for (int i = 0; i < len; i++) {
            char item = origin.charAt(i);
        }

        String v2 = origin.trim(); // 去除空白

        String v3 = origin.toLowerCase(); // 小写
        String v4 = origin.toUpperCase(); // 大写

        String[] v5 = origin.split("是"); // 分割

        String v6 = origin.replace("D", "S"); // 替换

        String v7 = origin.substring(2, 6);  // 子字符串

        boolean v8 = origin.equals("alex是个大SB");

        boolean v9 = origin.contains("el");

        boolean v10 = origin.startsWith("a");

        String v11 = origin.concat("哈哈哈");
    }
}
```



关于StringBuilder，在Java开发中经常会使用，用于对字符串进行拼接处理。

```java
public class Hello {

    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("name=");
        sb.append("wupeiqi");
        sb.append("age=");
        sb.append("18");
        sb.append("&");
		
        // 删除指定位置的字符
        sb.deleteCharAt(sb.length()-1); // name=wupeiqiage=18
        
        sb.insert(12,"&"); // name=wupeiqi&age=18
        String dataString = sb.toString();

        System.out.println(dataString); //name=wupeiqi&age=18
    }
}
```





### 7.4 数组

数据，具有 相同数据类型且定长 的元素集合。【定长】

```java
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
        int[] numArray = new int[3];
        numArray[0] = 11;
        numArray[1] = 22;
        numArray[2] = 33;
        System.out.println(Arrays.toString(numArray));

        String[] names = new String[]{"武沛齐", "alex", "张开"};
        System.out.println(Arrays.toString(names));

        short[] number = {66, 99};
        System.out.println(Arrays.toString(number));

        for (int i = 0; i < names.length; i++) {
            String item = names[i];
            System.out.println(item);
        }

        for (String item : names) {
            System.out.println(item);
        }

    }
}
```



```java
public class Hello {

    public static void main(String[] args) {
        /*
            多维数据
              data=[
                    [11,22],
                    [33,44]
                    [55,66]
                ]
         */
        int[][] numArray = new int[3][2];
        numArray[0] = new int[]{11, 22};
        numArray[1] = new int[]{33, 44};
        numArray[2] = new int[]{55, 66};
    }
}
```





















### 7.5 List系列

List是一个接口，常见实现这个接口的有两个类，用于实现变长的数组。

- ArrayList，底层是连续的位置存储，类似于数组。（内部自动扩容）。

  ```
  11,22,333
  ```

- LinkedList，底层是基于链表来存储。



ArrayList示例：

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
		
        // ArrayList，内部存放的是混合数据类型。
        // ArrayList<String> data = new ArrayList<String>();
        ArrayList data = new ArrayList();
        data.add("武沛齐");
        data.add("alex");
        data.add(666);
        data.add("tony");
		
        String value = data.get(1);
        
        // String value = (String) data.get(1);
        Object temp = data.get(1);
        String value = (String) temp; // 转化可转换的数据
        System.out.println(value);


        int xo = (int) data.get(2);
        System.out.println(xo);

        data.set(0, "哈哈哈哈");
        System.out.println(data);

        data.remove("eric");
        data.remove(0);
        System.out.println(data);

        int size = data.size();
        System.out.println(size);

        boolean exists = data.contains("武沛齐");
        System.out.println(exists);


        for (Object item : data) {
            System.out.println(item);
        }

        for (int i = 0; i < data.size(); i++) {
            Object item = data.get(i);
            System.out.println(item);
        }
    }
}
```



```java
import java.util.LinkedList;

public class Hello {

    public static void main(String[] args) {
        LinkedList<Integer> v1 = new LinkedList<Integer>();
        v1.add(11);
        v1.add(22);

        LinkedList<Object> v2 = new LinkedList<Object>();
        v2.add("有阪深雪");
        v2.add("大桥未久");
        v2.add(666);
        v2.add(123);

        //v2.remove(1);
        //v2.remove("路飞");

        v2.set(2, "苍老师");
        v2.push("哈哈哈");
        // v2.addFirst(11);


        for (int i = 0; i < v2.size(); i++) {
            Object item = v2.get(i);
            System.out.println(item);
        }

        for (Object item : v2) {
            System.out.println(item);
        }
    }
}
```



关于迭代器：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        ArrayList s1 = new ArrayList();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        Iterator it = s1.iterator(); // 迭代器
        while (it.hasNext()) {
            String item = (String) it.next();
            System.out.println(item);
        }
    }
}
```



关于foreach

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        ArrayList s1 = new ArrayList();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");

		// JDK8
        s1.forEach(item -> {
            System.out.println(item);
        });
    }
}

```





关于 List、ArrayList、LinkedList

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Hello {

    public static void main(String[] args) {
        List<Integer> v1 = new LinkedList<Integer>();
        v1.add(11);
        v1.add(22);

        List v2 = new ArrayList();
        v2.add(11);
        v2.add("哈哈哈");

        List<Integer> v3 = new ArrayList<Integer>();
        v1.add(11);
        v1.add(22);
    }
}
```



直接创建：

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Hello {

    public static void main(String[] args) {
        List<Integer> v1 = new LinkedList<Integer>() {
            {
                add(11);
                add(22);
            }
        };

    }
}
```





### 7.6 Set系列

Set是一个接口，常见实现这个接口的有两个类，用于实现不重复的多元素集合。

- HashSet，去重，无序。
- TreeSet，去重，内部默认排序（同类型元素，无法比较大小）。

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        // Set s1 = new HashSet();
        // HashSet<String> s1 = new HashSet<String>();
        HashSet s1 = new HashSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");
        s1.add("P站");
        s1.add(666);
        System.out.println(s1); // [B站, A站, P站,666]

        HashSet s2 = new HashSet(){
            {
                add("东京热");
                add("东北热");
                add("南京热");
            }
        };
        System.out.println(s2); // [B站, A站, P站]



        // Set s2 = new TreeSet();
        // TreeSet<String> s2 = new TreeSet<String>();
        TreeSet s3 = new TreeSet();
        s3.add("P站");
        s3.add("B站");
        s3.add("A站");
        s3.add("P站");
        // s3.add(666); //不可以

        System.out.println(s3); // [B站, A站, P站]

        TreeSet s4 = new TreeSet(){
            {
                add("P站");
                add("B站");
                add("A站");
                add("P站");
            }
        };
        System.out.println(s4); // [B站, A站, P站]

    }
}
```



关于交并差：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        // Set s1 = new HashSet();
        HashSet s1 = new HashSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");
        s1.remove("P站");
        System.out.println(s1); // [B站, A站, P站]

        boolean exists = s1.contains("B站");
        System.out.println(exists);

        HashSet s2 = new HashSet();
        s2.add(123);
        s2.add(456);


        HashSet v1 = new HashSet();
        v1.addAll(s1);
        v1.retainAll(s2); // 交集
        System.out.println(v1);


        HashSet v2 = new HashSet();
        v2.addAll(s1);
        v2.addAll(s2); // 并集
        System.out.println(v2);

        HashSet v3 = new HashSet();
        v3.addAll(s1);
        v3.removeAll(s2); // 差集 s1 - s2
        System.out.println(v3);


        HashSet v4 = new HashSet();
        v4.addAll(s2);
        v4.removeAll(s1); // 差集 s2 - s1
        System.out.println(v4);
    }
}
```



关于循环获取：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");

        for (Object item : s1) {
            System.out.println(item);
        }

        // 不用这种循环
        for(int i=0;i<s1.size();i++){
            // Object item = s1[i]     不支持
            // Object item = s1.get(i) 不支持
        }
    }
}
```



关于迭代器：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        Iterator it = s1.iterator();
        while (it.hasNext()) {
            String item = (String) it.next();
            System.out.println(item);
        }
    }
}
```



关于foreach

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        s1.forEach(item -> {
            System.out.println(item);
        });
    }
}
```





### 7.7 Map系列

Map是一个接口，常见实现这个接口的有两个类，用于存储键值对。

- HashMap，无序。
- TreeMap，默认根据key排序。

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        HashMap h1 = new HashMap();
        h1.put("name","alex");
        h1.put("age",18);
        h1.put("hobby","男");
        System.out.println(h1); // {gender=男, name=alex, age=18}

        HashMap<String,String> h2 = new HashMap<String,String>();
        h2.put("name","alex");
        h2.put("age","18");
        h2.put("hobby","男");
        System.out.println(h2); // {gender=男, name=alex, age=18}


        HashMap<String,String> h3 = new HashMap<String,String>(){
            {
                put("name","alex");
                put("age","18");
                put("hobby","男");
            }
        };
        System.out.println(h3); // {gender=男, name=alex, age=18}


        Map h4 = new HashMap();
        h4.put("name","alex");
        h4.put("age",18);
        h4.put("hobby","男");
        System.out.println(h4); // {gender=男, name=alex, age=18}
    }
}
```

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        TreeMap h1 = new TreeMap(); // 改为了TreeMap
        h1.put("name","alex");
        h1.put("age",18);
        h1.put("hobby","男");
        System.out.println(h1); // {age=18, hobby=男, name=alex}

        TreeMap<String,String> h2 = new TreeMap<String,String>();
        h2.put("name","alex");
        h2.put("age","18");
        h2.put("hobby","男");
        System.out.println(h2); // {age=18, hobby=男, name=alex}


        TreeMap<String,String> h3 = new TreeMap<String,String>(){
            {
                put("name","alex");
                put("age","18");
                put("hobby","男");
            }
        };
        System.out.println(h3); // {age=18, hobby=男, name=alex}


        Map h4 = new TreeMap();
        h4.put("name","alex");
        h4.put("age",18);
        h4.put("hobby","男");
        System.out.println(h4); // {age=18, hobby=男, name=alex}
    }
}
```



常见操作：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        TreeMap h1 = new TreeMap(); // 改为了TreeMap
        h1.put("name", "alex");
        h1.put("age", "18");
        h1.put("hobby", "男");
        h1.put("hobby", "女人");

        h1.remove("age");
        int size = h1.size();

        Object value = h1.get("name"); // 不存在，返回null
        System.out.println(value);

        boolean existsKey = h1.containsKey("age");
        boolean existsValue = h1.containsValue("alex");

        h1.replace("name", "李杰");
        System.out.println(h1);


        // 循环: 示例1
        Set<Map.Entry<String, String>> s1 = h1.entrySet();
        Iterator it1 = s1.iterator();
        while (it1.hasNext()) {
            Map.Entry<String, String> entry = (Map.Entry<String, String>) it1.next();
            String k = (String) entry.getKey();
            String v = (String) entry.getValue();
        }

        // 循环: 示例2
        Set s2 = h1.entrySet();
        Iterator it2 = s2.iterator();
        while (it2.hasNext()) {
            Map.Entry entry = (Map.Entry) it2.next();
            String k = (String) entry.getKey();
            String v = (String) entry.getValue();
        }

        // 循环: 示例3
        TreeMap<String, String> h2 = new TreeMap<String, String>(); // 改为了TreeMap
        h2.put("name", "alex");
        h2.put("age", "18");
        for (Map.Entry<String, String> entry : h2.entrySet()) {
            String k = entry.getKey();
            String v = entry.getValue();
        }

        // 循环: 示例4
        TreeMap h3 = new TreeMap(); // 改为了TreeMap
        h3.put("name", "alex");
        h3.put("age", 18);
        for (Object entry : h3.entrySet()) {
            Map.Entry<String, Object> entryMap = (Map.Entry<String, Object>) entry;
            String k = entryMap.getKey();
            Object v = entryMap.getValue();
            if (v instanceof Integer) {
                System.out.println("数字：" + Integer.toString((Integer) v));
            } else if (v instanceof String) {
                System.out.println("字符串：" + (String) v);
            } else {
                System.out.println("未知类型：" + v.toString());
            }
        }

        // 循环: 示例5（JDK8）
        TreeMap h4 = new TreeMap(); // 改为了TreeMap
        h4.put("name", "alex");
        h4.put("age", 18);
        h4.forEach((k, v) -> {
            System.out.print(k + "：" + v + "   v的类型是：");
            System.out.println(v.getClass());
        });
    }
}
```



上述就是关于Java中常见数据类型的操作，了解上述的内容之后，再来看B站逆向的代码案例，例如：



![image-20210928193550689](爬虫.assets/image-20210928193550689.png)

![image-20210928193623922](爬虫.assets/image-20210928193623922.png)



## 8.面向对象相关（一）



### 8.1 类和对象

```java
class Person {

    // 实例变量
    public String name;
    public Integer age;
    public String email;

    // 构造方法1
    public Person() {
        this.name = "Eric";
        this.age = 99999;
    }

    // 构造方法2
    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
        this.email = "xxx@live.com";
    }

    // 构造方法3
    public Person(String name, String email) {
        this.name = name;
        this.age = 83;
        this.email = email;
    }
	
    // 定义函数（重载）
    public void doSomething() {
        System.out.println(this.name);
    }

	// 定义函数（重载）
    public void doSomething(String prev) {
        String text = String.format("%s-%s", prev, this.name);
        System.out.println(text);
    }

}

public class Hello {

    public static void main(String[] args) {
		
        // 实例化对象时，体现的主要是封装。
        Person p1 = new Person();
        Person p2 = new Person("alex", 73);
        Person p3 = new Person("tony", "alex@sb.com");

        p1.doSomething();
        p1.doSomething("你好呀，");

        p2.doSomething();
        p2.doSomething("你好呀，");
        
        p3.doSomething();
        p3.doSomething("你好呀，");
    }
}
```



### 8.2 继承和多态

Java中只是支持单继承（同时只能继承一个基类）。

```java
class Base {
    public String email;

    public Base(String email) {
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public String name;
    public Integer age;

    public Person(String name, Integer age, String email) {
        super(email);
        this.name = name;
        this.age = age;
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void main(String[] args) {
        Person p = new Person("武沛齐", 73, "wupeiqi@live.com");
        String text = p.getInfo();
        System.out.println(text);

        String subText = p.getSubInfo();
        System.out.println(subText);
    }
}
```



特别的：使用类的继承关系，也可以在 传参 或 指定类型时，可以用基类 泛指 所有继承他的子类（多态）。

```java
import java.util.ArrayList;

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void main(String[] args) {

        Base[] v1 = {
                new Base("alex", 73, "alex@live.com"),
                new Base("武沛齐", 23, "wupeiqi@live.com"),
                new Person("日天", 83, "ritian@live.com"),
                new Person("张开", 13, "zhangkai@live.com"),
        };

        ArrayList<Base> v2 = new ArrayList<Base>() {
            {
                add(new Base("alex", 73, "alex@live.com"));
                add(new Base("武沛齐", 23, "wupeiqi@live.com"));
                add(new Person("日天", 83, "ritian@live.com"));
                add(new Person("张开", 13, "zhangkai@live.com"));
            }
        };

        for (Base item : v2) {
            String info = item.getSubInfo(); 
            System.out.println(info);
        }
        
        for (Base item : v2) {
            String info = null;
            if (item instanceof Person) {
                info = ((Person) item).getInfo();
            } else {
                info = item.getSubInfo();
            }
            System.out.println(info);
        }
        
    }
}


```

```java
class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void action(Base obj) {
        String info = obj.getSubInfo();
        System.out.println(info);
    }

    public static void main(String[] args) {
        Base p1 = new Base("alex", 73, "alex@live.com");
        Person p2 = new Person("日天", 83, "ritian@live.com");
        Base p3 = new Person("张开", 83, "zhangkai@live.com");

        action(p1);
        action(p2);
        action(p3);
    }
}
```



### 8.3 接口

接口的作用：约束、泛指实现他的类型。



约束：

```java
interface IPerson {
    public void f1();

    public void f1(int age);

    public void f2(String info);
}

interface IUser {
    public String f3(int num);
}

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base implements IUser, IPerson {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }

    public void f1() {
        System.out.println("F1,无参数");
    }

    public void f1(int age) {
        System.out.println("F1,age参数");
    }

    public void f2(String info) {
        System.out.println("F2");
    }

    public String f3(int num) {
        return "哈哈哈";
    }
}

public class Hello {


    public static void main(String[] args) {
        Person p = new Person("日天", 83, "ritian@live.com");
        p.f1();
    }
}

```



泛指一些类型：

```java
interface IAnimal {
    public void exec();

}

class Dog implements IAnimal {
    public void exec() {
        System.out.println("狗子");
    }
}

class Cat implements IAnimal {
    public void exec() {
        System.out.println("猫咪");
    }
}

public class Hello {

    public static void action(IAnimal obj) {
        obj.exec();
    }

    public static void main(String[] args) {
        IAnimal[] v1 = {
                new Dog(),
                new Dog(),
                new Cat(),
                new Cat(),
        };
        for (IAnimal item : v1) {
            item.exec();
        }

        for (IAnimal item : v1) {
            action(item);
        }
    }
}
```

```java
interface IPerson {
    public void f1();

    public void f1(int age);

    public void f2(String info);
}

interface IUser {
    public String f3(int num);
}

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base implements IUser, IPerson {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }

    public void f1() {
        System.out.println("F1,无参数");
    }

    public void f1(int age) {
        System.out.println("F1,age参数");
    }

    public void f2(String info) {
        System.out.println("F2");
    }

    public String f3(int num) {
        return "哈哈哈";
    }
}

public class Hello {


    public static void main(String[] args) {
        IPerson[] v1 = {
                new Person("日天", 83, "ritian@live.com"),
                new Person("张开", 13, "zhangkai@live.com"),
        };
        for (IPerson item : v1) {
            item.f1();
            // item.f3(); 错误
        }
    }
}
```



















# Java开发基础（下）

## 1. 数据类型相关



### 1.1 整数类型

- byte，字节		  【1字节】表示范围：-128 ~ 127 即：`-2^7 ~ 2^7 -1  `  
- short，短整型    【2字节】表示范围：-32768 ~ 32767
- int，整型             【4字节】表示范围：-2147483648 ~ 2147483647
- long，长整型      【8字节】表示范围：-9223372036854775808 ~ 9223372036854775807

```java
public class Hello {

    public static void main(String[] args) {
        byte v1 = 32;
        short v2 = 10000;
        int v3 = 22221331;
        long v4 = 554534353424L;
    }
}
```



```java
public class Hello {
    public static void main(String[] args) {
        short v1 = 32;
        // 强制类型转换
        int v2 = (int)v1;
        System.out.println(v2);
    }
}
```



**特别提醒**：在逆向时经常会看到byte数组表示字符串。

```java
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
        // byte数组，每个元素都是一个字节 [11,22,33,44,55]
        byte[] data = {97, 105, 100, 61, 50, 52, 54, 51, 56, 55, 53, 55, 49, 38, 97, 117, 116, 111, 95, 112, 108, 97, 121, 61, 48, 38, 99, 105, 100, 61, 50, 56, 57, 48, 48, 56, 52, 52, 49, 38, 100, 105, 100, 61, 75, 82, 69, 104, 69, 83, 77, 85, 74, 104, 56, 116, 70, 67, 69, 86, 97, 82, 86, 112, 69, 50, 116, 97, 80, 81, 107, 55, 87, 67, 104, 67, 74, 103, 38, 101, 112, 105, 100, 61, 48, 38, 102, 116, 105, 109, 101, 61, 49, 54, 50, 55, 49, 48, 48, 57, 51, 55, 38, 108, 118, 61, 48, 38, 109, 105, 100, 61, 48, 38, 112, 97, 114, 116, 61, 49, 38, 115, 105, 100, 61, 48, 38, 115, 116, 105, 109, 101, 61, 49, 54, 50, 55, 49, 48, 52, 51, 55, 50, 38, 115, 117, 98, 95, 116, 121, 112, 101, 61, 48, 38, 116, 121, 112, 101, 61, 51}; // 这里应该表示的是一个字符串。

        String dataString = new String(data);
        System.out.println("字节数组转换为字符串：" + dataString);

        
        
        // 字符串也可以转换成字节
        byte[] res = dataString.getBytes();
        System.out.println(Arrays.toString(res));

        try{
            String name = "武沛齐";
            // v1 = [-50, -28, -59, -26, -58, -21] Java中
            // v2 = [206, 228, 197, 230, 198, 235] Python中
            byte[] v1 = name.getBytes("GBK");
            System.out.println(Arrays.toString(v1));

            byte[] v2 = name.getBytes("UTF-8"); // 默认
            System.out.println(Arrays.toString(v2));
        }catch (Exception e){

        }
    }
}
```

```python
# Python脚本，方便你们以后使用。
byte_list = [-50, -28, -59, -26, -58, -21]

bs = bytearray() # python字节数组
for item in byte_list:
    if item < 0:
        item = item + 256
    bs.append(item)
str_data = bs.decode('gbk')  # data = bytes(bs)
print(str_data)
```



**进制转换**：在java中除了十进制以外，其他的进制都是用字符串来表示。

```java
public class Hello {

    public static void main(String[] args) {
        // 十进制转其他
        int n = 18;
        
        String v2 = Integer.toBinaryString(n); // 二进制，字符串形式
        String v8 = Integer.toOctalString(n);
        String v16 = Integer.toHexString(n);
        String v3 = Integer.toString(n,3);
        
        String dataStr = Integer.toString(n); // "18"
        
        // 其他转十进制
        String data = "10010";
        int v10 = Integer.parseInt(data,2);
        
        // 其实：Integer.toString 和 Integer.parseInt 其实就是整型和字符串之间的转换。
    }
}
```





















### 7.2 字符

```java
char v1 = '武'; // 字符
String v2 = "武沛齐"; // 字符串
```





字符，char		【2字节】对应的是unicode中的码点，用于存储单个字符。

```java
public class Hello {

    public static void main(String[] args) {
        String text = "alex是个大傻B";

        char v1 = text.charAt(1);
        System.out.println(v1); // l

        char v2 = text.charAt(2);
        System.out.println(v2); // e

        char v3 = '中'; // 单引号
        System.out.println(v3);

        char v4 = 'A'; // 单引号   65
        char v5 = '#'; // 单引号   35
        
        int v6 = v4 + v5; // 十进制 100
        System.out.println(v6); //100

        char v7 = (char)v6;
        System.out.println(v7); // d
    }
}
```









### 7.3 字符串

```java
import java.io.UnsupportedEncodingException;

public class Hello {

    public static void main(String[] args) throws UnsupportedEncodingException {
        String v1 = "武沛齐";
        String v2 = new String("武沛齐");

        // char[] data = new char[]{'武', '沛', '齐'};
        // char[] data = {'武', '沛', '齐'};
        // String v3 = new String(data);
        String v3 = new String(new char[]{'武', '沛', '齐'});

        String v4 = new String(new byte[]{-26, -83, -90, -26, -78, -101, -23, -67, -112});
        String v5 = new String(new byte[]{-50, -28, -59, -26, -58, -21},"GBK");
		
        // 上面都是不可变  "alex" + "SB" + "xx" + "xxxx"
        // 可变字符串 "name=wupeiqi"
        StringBuilder sb = new StringBuilder(); 
        sb.append("name");
        sb.append("=");
        sb.append("wupeiqi");
        sb.append("&");
        sb.append("age=");
        sb.append("999");
        // String v6 = sb.toString(); //name=wupeqi&age=999
        String v6 = new String(sb);

        StringBuffer strBuffer = new StringBuffer(); // 线程安全（多线程）
        strBuffer.append("name");
        strBuffer.append("=");
        strBuffer.append("wupeiqi");
        strBuffer.append("&");
        strBuffer.append("age=");
        strBuffer.append("999");
        // String v6 = strBuffer.toString();
        String v7 = new String(strBuffer);


        
        // 其他类型的方法执行，直接返回一个字符串
        String v8 = Integer.toString(123123);
        String v9 = Double.toString(3.14);
        
        // 或这
        String v10 = String.valueOf(123);
    }
}
```



对于字符串，内部提供了很多方便的方法对他进行操作，例如：

```java
public class Hello {

    public static void main(String[] args) {
        String origin = "alex是个大DB";

        char v1 = origin.charAt(5); // 指定字符
        int len = origin.length();  // 长度
        for (int i = 0; i < len; i++) {
            char item = origin.charAt(i);
        }

        String v2 = origin.trim(); // 去除空白

        String v3 = origin.toLowerCase(); // 小写
        String v4 = origin.toUpperCase(); // 大写

        String[] v5 = origin.split("是"); // 分割

        String v6 = origin.replace("D", "S"); // 替换

        String v7 = origin.substring(2, 6);  // 子字符串

        boolean v8 = origin.equals("alex是个大SB");

        boolean v9 = origin.contains("el");

        boolean v10 = origin.startsWith("a");

        String v11 = origin.concat("哈哈哈");
    }
}
```



关于StringBuilder，在Java开发中经常会使用，用于对字符串进行拼接处理。

```java
public class Hello {

    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append("name=");
        sb.append("wupeiqi");
        sb.append("age=");
        sb.append("18");
        sb.append("&");
		
        // 删除指定位置的字符
        sb.deleteCharAt(sb.length()-1); // name=wupeiqiage=18
        
        sb.insert(12,"&"); // name=wupeiqi&age=18
        String dataString = sb.toString();

        System.out.println(dataString); //name=wupeiqi&age=18
    }
}
```





### 1.4 数组

数据，具有 相同数据类型且定长 的元素集合。【定长】

```java
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
        int[] numArray = new int[3];
        numArray[0] = 11;
        numArray[1] = 22;
        numArray[2] = 33;
        System.out.println(Arrays.toString(numArray));

        String[] names = new String[]{"武沛齐", "alex", "张开"};
        System.out.println(Arrays.toString(names));

        short[] number = {66, 99};
        System.out.println(Arrays.toString(number));

        for (int i = 0; i < names.length; i++) {
            String item = names[i];
            System.out.println(item);
        }

        for (String item : names) {
            System.out.println(item);
        }

    }
}
```



```java
public class Hello {

    public static void main(String[] args) {
        /*
            多维数据
              data=[
                    [11,22],
                    [33,44]
                    [55,66]
                ]
         */
        int[][] numArray = new int[3][2];
        numArray[0] = new int[]{11, 22};
        numArray[1] = new int[]{33, 44};
        numArray[2] = new int[]{55, 66};
    }
}
```



### 1.5 List系列

List是一个接口，常见实现这个接口的有两个类，用于实现变长的数组。

- ArrayList，底层是连续的位置存储，类似于数组。（内部自动扩容）。

  ```
  11,22,333
  ```

- LinkedList，底层是基于链表来存储。



```java
List l1 = new ArrayList();
List l2 = new LinkedList();
```







ArrayList示例：

```java
import java.util.ArrayList;
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {
		
        // ArrayList，内部存放的是混合数据类型。
        // ArrayList<String> data = new ArrayList<String>();
        ArrayList data = new ArrayList();
        data.add("武沛齐");
        data.add("alex");
        data.add(666);
        data.add("tony");
		
        String value = data.get(1);
        
        // String value = (String) data.get(1);
        Object temp = data.get(1);
        String value = (String) temp; // 转化可转换的数据
        System.out.println(value);


        int xo = (int) data.get(2);
        System.out.println(xo);

        data.set(0, "哈哈哈哈");
        System.out.println(data);

        data.remove("eric");
        data.remove(0);
        System.out.println(data);

        int size = data.size();
        System.out.println(size);

        boolean exists = data.contains("武沛齐");
        System.out.println(exists);


        for (Object item : data) {
            System.out.println(item);
        }

        for (int i = 0; i < data.size(); i++) {
            Object item = data.get(i);
            System.out.println(item);
        }
    }
}
```



```java
import java.util.LinkedList;

public class Hello {

    public static void main(String[] args) {
        LinkedList<Integer> v1 = new LinkedList<Integer>();
        v1.add(11);
        v1.add(22);

        LinkedList<Object> v2 = new LinkedList<Object>();
        v2.add("有阪深雪");
        v2.add("大桥未久");
        v2.add(666);
        v2.add(123);

        //v2.remove(1);
        //v2.remove("路飞");

        v2.set(2, "苍老师");
        v2.push("哈哈哈");
        // v2.addFirst(11);


        for (int i = 0; i < v2.size(); i++) {
            Object item = v2.get(i);
            System.out.println(item);
        }

        for (Object item : v2) {
            System.out.println(item);
        }
    }
}
```



关于迭代器：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        ArrayList s1 = new ArrayList();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        Iterator it = s1.iterator(); // 迭代器
        while (it.hasNext()) {
            String item = (String) it.next();
            System.out.println(item);
        }
    }
}
```



关于foreach

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        ArrayList s1 = new ArrayList();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");

		// JDK8
        s1.forEach(item -> {
            System.out.println(item);
        });
    }
}

```





关于 List、ArrayList、LinkedList

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Hello {

    public static void main(String[] args) {
        List<Integer> v1 = new LinkedList<Integer>();
        v1.add(11);
        v1.add(22);

        List v2 = new ArrayList();
        v2.add(11);
        v2.add("哈哈哈");

        List<Integer> v3 = new ArrayList<Integer>();
        v1.add(11);
        v1.add(22);
    }
}
```



直接创建：

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Hello {

    public static void main(String[] args) {
        List<Integer> v1 = new LinkedList<Integer>() {
            {
                add(11);
                add(22);
            }
        };

    }
}
```





### 1.6 Set系列

Set是一个接口，常见实现这个接口的有两个类，用于实现不重复的多元素集合。

- HashSet，去重，无序。
- TreeSet，去重，内部默认排序（同类型元素，无法比较大小）。

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        // Set s1 = new HashSet();
        // HashSet<String> s1 = new HashSet<String>();
        HashSet s1 = new HashSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");
        s1.add("P站");
        s1.add(666);
        System.out.println(s1); // [B站, A站, P站,666]

        HashSet s2 = new HashSet(){
            {
                add("东京热");
                add("东北热");
                add("南京热");
            }
        };
        System.out.println(s2); // [B站, A站, P站]



        // Set s2 = new TreeSet();
        // TreeSet<String> s2 = new TreeSet<String>();
        TreeSet s3 = new TreeSet();
        s3.add("P站");
        s3.add("B站");
        s3.add("A站");
        s3.add("P站");
        // s3.add(666); //不可以

        System.out.println(s3); // [B站, A站, P站]

        TreeSet s4 = new TreeSet(){
            {
                add("P站");
                add("B站");
                add("A站");
                add("P站");
            }
        };
        System.out.println(s4); // [B站, A站, P站]

    }
}
```



关于交并差：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        // Set s1 = new HashSet();
        HashSet s1 = new HashSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");
        s1.remove("P站");
        System.out.println(s1); // [B站, A站, P站]

        boolean exists = s1.contains("B站");
        System.out.println(exists);

        HashSet s2 = new HashSet();
        s2.add(123);
        s2.add(456);


        HashSet v1 = new HashSet(); // 空  [B站, A站, P站]
        v1.addAll(s1);
        v1.retainAll(s2); // 交集
        System.out.println(v1);


        HashSet v2 = new HashSet();
        v2.addAll(s1);
        v2.addAll(s2); // 并集
        System.out.println(v2);

        HashSet v3 = new HashSet();
        v3.addAll(s1);
        v3.removeAll(s2); // 差集 s1 - s2
        System.out.println(v3);


        HashSet v4 = new HashSet();
        v4.addAll(s2);
        v4.removeAll(s1); // 差集 s2 - s1
        System.out.println(v4);
    }
}
```



关于循环获取：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");

        for (Object item : s1) {
            System.out.println(item);
        }

        // 不用这种循环
        for(int i=0;i<s1.size();i++){
            // Object item = s1[i]     不支持
            // Object item = s1.get(i) 不支持
        }
    }
}
```



关于迭代器：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        Iterator it = s1.iterator();
        while (it.hasNext()) {
            String item = (String) it.next();
            System.out.println(item);
        }
    }
}
```



关于foreach

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {

        TreeSet s1 = new TreeSet();
        s1.add("P站");
        s1.add("B站");
        s1.add("A站");


        s1.forEach(item -> {
            System.out.println(item);
        });
    }
}
```





### 1.7 Map系列

Map是一个接口，常见实现这个接口的有两个类，用于存储键值对。

- HashMap，无序。

- TreeMap，默认根据key排序。

  ```python
  data_dict = {
      "aid": "123",
      "cid": "44",
      "bid": "5",
  }
  
  data_list = ["{}={}".format(key, data_dict[key]) for key in sorted(data_dict.keys())]
  res = "&".join(data_list)
  print(res)
  ```

  

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        HashMap h1 = new HashMap();
        h1.put("name","alex");
        h1.put("age",18);
        h1.put("hobby","男");
        System.out.println(h1); // {gender=男, name=alex, age=18}

        HashMap<String,String> h2 = new HashMap<String,String>();
        h2.put("name","alex");
        h2.put("age","18");
        h2.put("hobby","男");
        System.out.println(h2); // {gender=男, name=alex, age=18}


        HashMap<String,String> h3 = new HashMap<String,String>(){
            {
                put("name","alex");
                put("age","18");
                put("hobby","男");
            }
        };
        System.out.println(h3); // {gender=男, name=alex, age=18}
    }
}
```

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        TreeMap h1 = new TreeMap(); // 改为了TreeMap
        h1.put("name","alex");
        h1.put("age",18);
        h1.put("hobby","男");
        System.out.println(h1); // {age=18, hobby=男, name=alex}

        TreeMap<String,String> h2 = new TreeMap<String,String>();
        h2.put("name","alex");
        h2.put("age","18");
        h2.put("hobby","男");
        System.out.println(h2); // {age=18, hobby=男, name=alex}


        TreeMap<String,String> h3 = new TreeMap<String,String>(){
            {
                put("name","alex");
                put("age","18");
                put("hobby","男");
            }
        };
        System.out.println(h3); // {age=18, hobby=男, name=alex}


        Map h4 = new TreeMap();
        h4.put("name","alex");
        h4.put("age",18);
        h4.put("hobby","男");
        System.out.println(h4); // {age=18, hobby=男, name=alex}
    }
}
```



常见操作：

```java
import java.util.*;

public class Hello {

    public static void main(String[] args) {
        TreeMap h1 = new TreeMap(); // 改为了TreeMap
        h1.put("name", "alex");
        h1.put("age", "18");
        h1.put("hobby", "男");
        h1.put("hobby", "女人");

        h1.remove("age");
        int size = h1.size();

        Object value = h1.get("name"); // 不存在，返回null
        System.out.println(value);

        boolean existsKey = h1.containsKey("age");
        boolean existsValue = h1.containsValue("alex");

        h1.replace("name", "李杰");
        System.out.println(h1);


        // 循环: 示例1
        Set<Map.Entry<String, String>> s1 = h1.entrySet();
        Iterator it1 = s1.iterator();
        while (it1.hasNext()) {
            Map.Entry<String, String> entry = (Map.Entry<String, String>) it1.next();
            String k = (String) entry.getKey();
            String v = (String) entry.getValue();
        }

        // 循环: 示例2
        Set s2 = h1.entrySet();
        Iterator it2 = s2.iterator();
        while (it2.hasNext()) {
            Map.Entry entry = (Map.Entry) it2.next();
            String k = (String) entry.getKey();
            String v = (String) entry.getValue();
        }

        // 循环: 示例3
        TreeMap<String, String> h2 = new TreeMap<String, String>(); // 改为了TreeMap
        h2.put("name", "alex");
        h2.put("age", "18");
        for (Map.Entry<String, String> entry : h2.entrySet()) {
            String k = entry.getKey();
            String v = entry.getValue();
        }

        // 循环: 示例4
        TreeMap h3 = new TreeMap(); // 改为了TreeMap
        h3.put("name", "alex");
        h3.put("age", 18);
        
        for (Object entry : h3.entrySet()) {
            Map.Entry<String, Object> entryMap = (Map.Entry<String, Object>) entry;
            String k = entryMap.getKey();
            Object v = entryMap.getValue(); // 18   "alex"
            
            if (v instanceof Integer) {
                System.out.println("数字：" + Integer.toString((Integer) v));
            } else if (v instanceof String) {
                System.out.println("字符串：" + (String) v);
            } else {
                System.out.println("未知类型：" + v.toString());
            }
        }

        // 循环: 示例5（JDK8）
        TreeMap h4 = new TreeMap(); // 改为了TreeMap
        h4.put("name", "alex");
        h4.put("age", 18);
        h4.forEach((k, v) -> {
            System.out.print(k + "：" + v + "   v的类型是：");
            System.out.println(v.getClass());
        });
    }
}
```



上述就是关于Java中常见数据类型的操作，了解上述的内容之后，再来看B站逆向的代码案例，例如：



![image-20210928193550689](爬虫.assets/image-20210928193550689-16539125201321.png)

![image-20210928193623922](爬虫.assets/image-20210928193623922-16539125201322.png)



## 2.面向对象

### 2.1 类和对象

```java
class Person {

    // 实例变量
    public String name;
    public Integer age;
    public String email;

    // 构造方法1
    public Person() {
        this.name = "Eric";
        this.age = 99999;
    }

    // 构造方法2
    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
        this.email = "xxx@live.com";
    }

    // 构造方法3
    public Person(String name, String email) {
        this.name = name;
        this.age = 83;
        this.email = email;
    }
	
    // 定义函数（重载）
    public void doSomething() {
        System.out.println(this.name);
    }

	// 定义函数（重载）
    public void doSomething(String prev) {
        String text = String.format("%s-%s", prev, this.name);
        System.out.println(text);
    }
}

public class Hello {

    public static void main(String[] args) {
		
        // 实例化对象时，体现的主要是封装。
        Person p1 = new Person();
        Person p2 = new Person("alex", 73);
        Person p3 = new Person("tony", "alex@sb.com");

        p1.doSomething();
        p1.doSomething("你好呀，");

        p2.doSomething();
        p2.doSomething("你好呀，");
        
        p3.doSomething();
        p3.doSomething("你好呀，");
    }
}
```



### 2.2 继承和多态 

Java中只是支持单继承（同时只能继承一个基类）。

```java
class Base {
    public String email;

    public Base(String email) {
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public String name;
    public Integer age;

    public Person(String name, Integer age, String email) {
        super(email);
        this.name = name;
        this.age = age;
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {
    
    public static void main(String[] args) {
        Person p = new Person("武沛齐", 73, "wupeiqi@live.com");
        String text = p.getInfo();
        System.out.println(text);

        String subText = p.getSubInfo();
        System.out.println(subText);
    }
}
```



用父类泛指子类的对象：

```java
class Base {
    public String email;

    // 构造方法
    public Base(String email) {
        this.email = email;
    }

    public String getInfo() {
        return "哈哈哈哈";
    }

    // 方法getSubInfo
    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public String name;
    public Integer age;

    public Person(String name, Integer age, String email) {
        // 找父类中的 构造方法并执行  this=self
        super(email);

        this.name = name;
        this.age = age;
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void main(String[] args) {
        // 1. 实例化Person对象  p = {email="wupeiqi@live.com" name="武沛齐",age=73 }
        Base p = new Person("武沛齐", 73, "wupeiqi@live.com");

        System.out.println(p.getClass());  // class Person
        // 1.可以自己判断类型，然后再做其他的处理。
        // 2.p可以强制类型转化弄成Person类型。
        // 3.做了泛指之后，
        String text = p.getSubInfo();  // 找到实际是那个类的对象，就去找当前对象对应类中的方法。
        System.out.println(text);    // 武沛齐-wupeiqi@live.com

        String data = p.getInfo();  // 武沛齐-73-wupeiqi@live.com
        System.out.println(data);


        // 调用p的getInfo方法。
//        String text = p.getInfo();
//        System.out.println(text);
//
//        // 调用p的getSubInfo
//        String subText = p.getSubInfo();
//        System.out.println(subText);
    }
}
```



特别的：使用类的继承关系，也可以在 传参 或 指定类型时，可以用基类 泛指 所有继承他的子类（多态）。

```java
import java.util.ArrayList;

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void main(String[] args) {

        Base[] v1 = {
                new Base("alex", 73, "alex@live.com"),
                new Base("武沛齐", 23, "wupeiqi@live.com"),
                new Person("日天", 83, "ritian@live.com"),
                new Person("张开", 13, "zhangkai@live.com"),
        };

        ArrayList<Base> v2 = new ArrayList<Base>() {
            {
                add(new Base("alex", 73, "alex@live.com"));
                add(new Base("武沛齐", 23, "wupeiqi@live.com"));
                add(new Person("日天", 83, "ritian@live.com"));
                add(new Person("张开", 13, "zhangkai@live.com"));
            }
        };

        for (Base item : v2) {
            String info = item.getSubInfo(); 
            System.out.println(info);
        }
        
        for (Base item : v2) {
            String info = null;
            if (item instanceof Person) {
                info = ((Person) item).getInfo();
            } else {
                info = item.getSubInfo();
            }
            System.out.println(info);
        }
        
    }
}


```

```java
class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }
}

public class Hello {

    public static void action(Base obj) {
        String info = obj.getSubInfo();
        System.out.println(info);
    }

    public static void main(String[] args) {
        Base p1 = new Base("alex", 73, "alex@live.com");
        Person p2 = new Person("日天", 83, "ritian@live.com");
        Base p3 = new Person("张开", 83, "zhangkai@live.com");

        action(p1);
        action(p2);
        action(p3);
    }
}
```







### 2.3 接口 

接口的作用：约束、泛指 ”实现“ 他的类型。



约束：

```java
import java.util.ArrayList;

interface IMessage {
    public void send();
}

class Wechat implements IMessage {
    public void send() {
        System.out.println("发送微信");
    }
}

class DingDing implements IMessage {
    public void send() {
        System.out.println("发送钉钉");
    }
}

class Sms implements IMessage {
    public void send() {
        System.out.println("发送短信");
    }
}

public class Hello {

    public static void main(String[] args) {
        ArrayList<IMessage> objList = new ArrayList<IMessage>() {
            {
                add(new Wechat());
                add(new DingDing());
                add(new Sms());
            }
        };
        objList.get(0).send();

    }
}
```





```java
interface IPerson {
    public void f1();

    public void f1(int age);

    public void f2(String info);
}

interface IUser {
    public String f3(int num);
}

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base implements IUser, IPerson {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }

    public void f1() {
        System.out.println("F1,无参数");
    }

    public void f1(int age) {
        System.out.println("F1,age参数");
    }

    public void f2(String info) {
        System.out.println("F2");
    }

    public String f3(int num) {
        return "哈哈哈";
    }
}

public class Hello {


    public static void main(String[] args) {
        Person p = new Person("日天", 83, "ritian@live.com");
        p.f1();
    }
}

```



泛指一些类型：

```java
interface IAnimal {
    public void exec();

}

class Dog implements IAnimal {
    public void exec() {
        System.out.println("狗子");
    }
}

class Cat implements IAnimal {
    public void exec() {
        System.out.println("猫咪");
    }
}

public class Hello {

    public static void action(IAnimal obj) {
        obj.exec();
    }

    public static void main(String[] args) {
        IAnimal[] v1 = {
                new Dog(),
                new Dog(),
                new Cat(),
                new Cat(),
        };
        for (IAnimal item : v1) {
            item.exec();
        }

        for (IAnimal item : v1) {
            action(item);
        }
    }
}
```

```java
interface IPerson {
    public void f1();

    public void f1(int age);

    public void f2(String info);
}

interface IUser {
    public String f3(int num);
}

class Base {
    public String name;
    public Integer age;
    public String email;

    public Base(String name, Integer age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    public String getSubInfo() {
        return String.format("%s", this.email);
    }
}

class Person extends Base implements IUser, IPerson {

    public Person(String name, Integer age, String email) {
        super(name, age, email);
    }

    public String getInfo() {
        return String.format("%s-%d-%s", this.name, this.age, this.email);
    }

    public String getSubInfo() {
        return String.format("%s-%s", this.name, this.email);
    }

    public void f1() {
        System.out.println("F1,无参数");
    }

    public void f1(int age) {
        System.out.println("F1,age参数");
    }

    public void f2(String info) {
        System.out.println("F2");
    }

    public String f3(int num) {
        return "哈哈哈";
    }
}

public class Hello {


    public static void main(String[] args) {
        IPerson[] v1 = {
                new Person("日天", 83, "ritian@live.com"),
                new Person("张开", 13, "zhangkai@live.com"),
        };
        for (IPerson item : v1) {
            item.f1();
            // item.f3(); 错误
        }
    }
}
```



### 2.4 抽象

在Java开发中可以基于 抽象方法 & 抽象类实现。

```java
// 抽象类
abstract class Base {

    // 抽象方法（约束子类中必须有这个方法）
    public abstract void play(String name);

    // 普通方法
    public void stop() {
        System.out.println("Stop");
    }
}

class Son extends Base {
    public void play(String name) {
        System.out.println("play");
    }
}

public class Hello {

    public static void main(String[] args) {
        Son obj = new Son();
        obj.play("hahha");
        obj.stop();
    }
}
```



也可以实现多态：

```java
abstract class Base {
    public abstract void play(String name);

    public void stop() {
        System.out.println("Stop");
    }
}

class Son extends Base {

    public void play(String name) {
        System.out.println("play");
    }
}

public class Hello {
    public static void func(Base obj){
        obj.play("hahha");
        obj.stop();
    }
    public static void main(String[] args) {
        Son obj = new Son();
        func(obj);
    }
}
```



### 2.5 其他

```java
class Foo {
    public static String name = "武沛齐";
    public int age;

    public Foo(){
        this.age = 19; // 实例变量
        
        System.out.println(Foo.name); // "武沛齐"
        Foo.name = "哈哈哈哈";
        System.out.println(Foo.name); // 
    }
}


public class Hello {

    public static void main(String[] args) {
        Foo obj = new Foo();
    }
}
```

```java
class Foo {
    private int age;

    public int getAge() {
        // 再加工
        return age;
    }

    public void setAge(int age) {
        // 再加工
        this.age = age;
    }

    public Foo(){
        this.age = 19;
    }
}


public class Hello {

    public static void main(String[] args) {
        Foo obj = new Foo();
        obj.setAge(99);
        int data = obj.getAge();
        System.out.println(data);
    }
}
```



## 3.逆向常见

### 3.1 接口中的方法

根据调用关系，最终找到接口中的方法了。

```java
interface IRequest {
    public void send(String url);
}

class Context {

    public IRequest req;

    public Context(IRequest req) {
        this.req = req;
    }

    public void doRequest() {
        String url = "/click/android2/";
        this.req.send(url);
    }
}


public class Hello {

    public static void main(String[] args) {

    }
}
```



- 思路1：寻找实现了 IRequest 接口的类。
- 思路2：谁传入的req？找他的调用栈。







### 3.2 隐藏的字节

```java
String v4 = new String(new byte[]{-26, -83, -90, -26, -78, -101, -23, -67, -112});
```



### 3.3 UUID

抖音udid

![image-20211012191034675](爬虫.assets/image-20211012191034675.png)

```java
import java.util.UUID;

public class Hello {

    public static void main(String[] args){
        String uid = UUID.randomUUID().toString();
        System.out.println(uid);
    }
}
```





### 3.4 随机值

抖音：openudid

![image-20211012190908863](爬虫.assets/image-20211012190908863.png)

```java
import java.math.BigInteger;
import java.security.SecureRandom;

public class Hello {

    public static void main(String[] args) {
        // 随机生成80位，10个字节
        BigInteger v4 = new BigInteger(80, new SecureRandom());
        // 让字节以16进制展示
        String res = v4.toString(16);
        System.out.println(res);

    }
}
```

```python
import random

open_udid = "".join([hex(i)[2:] for i in random.randbytes(10)])
print(open_udid)
```



### 3.5 时间戳

抖音：_ticket

![image-20211012192006825](爬虫.assets/image-20211012192006825.png)

```java
public class Hello {

    public static void main(String[] args) {
        String t1 = String.valueOf(System.currentTimeMillis() / 1000);
        String t2 = String.valueOf(System.currentTimeMillis());

        System.out.println(t1);
        System.out.println(t2);
    }
}
```



### 3.6 十六进制字符串



![image-20211012191556212](爬虫.assets/image-20211012191556212.png)



```java
import java.util.Arrays;

public class Hello {

    public static void main(String[] args) {

        String name = "\n武沛齐";
        byte[] nameBytes =name.getBytes();

        // [10, -26, -83, -90, -26, -78, -101, -23, -67, -112]
        //  0a   e6    ad   a6
        System.out.println(Arrays.toString(nameBytes));
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<nameBytes.length;i++){
            int val = nameBytes[i] & 255;  // 负数转换为正数（byte，正数、负数）
            if (val<16){
                sb.append("0");
            }
            sb.append(Integer.toHexString(val));
        }
        String res = sb.toString();
        System.out.println(res); // e6ada6e6b29be9bd90

    }
}
```

```python
name = "武沛齐"

data_list = []
for item in name.encode('utf-8'):
    val = hex(item)
    data = val[2:].zfill(2)
    data_list.append(data)

result = ''.join(data_list)
print(result) # e6ada6e6b29be9bd90
```



### 3.7 base64处理

```java
import java.util.Base64;

public class Hello {

    public static void main(String[] args) {
        String name = "武沛齐";
        Base64.Encoder encoder  = Base64.getEncoder();
        String res = encoder.encodeToString(name.getBytes());
        System.out.println(res); // 5q2m5rKb6b2Q

        Base64.Decoder decoder  = Base64.getDecoder();
        byte[] origin = decoder.decode(res);
        String data = new String(origin);
        System.out.println(data); // 武沛齐

    }
}
```

```python
import base64

name = "武沛齐"

res = base64.b64encode(name.encode('utf-8'))
print(res) # b'5q2m5rKb6b2Q'


data = base64.b64decode(res)
print(data.decode('utf-8'))
```



### 3.8 md5加密

抖音：X-SS-STUB

![image-20211012192151809](爬虫.assets/image-20211012192151809.png)

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

public class Hello {

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String name = "武沛齐";
        MessageDigest instance = MessageDigest.getInstance("MD5");
        byte[] nameBytes = instance.digest(name.getBytes());
        System.out.println(Arrays.toString(nameBytes));

        String res = new String(nameBytes);
        System.out.println(res);

        // 十六进制展示
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<nameBytes.length;i++){
            int val = nameBytes[i] & 255;  // 负数转换为正数
            if (val<16){
                sb.append("0");
            }
            sb.append(Integer.toHexString(val));
        }
        String hexData = sb.toString();
        System.out.println(hexData); // e6ada6e6b29be9bd90
    }
}
```

```python
import hashlib

m = hashlib.md5()
m.update("武沛齐".encode("utf-8"))
v1 = m.digest()
print(v1) # b'\x175\x10\x12G$)\xd5-\x0c\r#\xd4h\x17='
v2 = m.hexdigest()
print(v2) # 17351012472429d52d0c0d23d468173d
```



md5加盐

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

public class Hello {

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String name = "武沛齐";
        MessageDigest instance = MessageDigest.getInstance("MD5");
        instance.update("xxxxxx".getBytes());
        byte[] nameBytes = instance.digest(name.getBytes());
        System.out.println(Arrays.toString(nameBytes));

        String res = new String(nameBytes);
        System.out.println(res);

        // 十六进制展示
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<nameBytes.length;i++){
            int val = nameBytes[i] & 255;  // 负数转换为正数
            if (val<16){
                sb.append("0");
            }
            sb.append(Integer.toHexString(val));
        }
        String hexData = sb.toString();
        System.out.println(hexData); // e6ada6e6b29be9bd90
    }
}
```



```java
import hashlib

m = hashlib.md5("xxxxxx".encode('utf-8'))
m.update("武沛齐".encode("utf-8"))
v1 = m.digest()
print(v1) # b'\x175\x10\x12G$)\xd5-\x0c\r#\xd4h\x17='
v2 = m.hexdigest()
print(v2) # 17351012472429d52d0c0d23d468173d

```



### 3.9 sha-256加密

B站：x/report/andriod2，请求体

![image-20211012191522515](爬虫.assets/image-20211012191522515.png)

![image-20211012191556212](爬虫.assets/image-20211012191556212.png)

```java
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

public class Hello {

    public static void main(String[] args) throws NoSuchAlgorithmException {
        String name = "武沛齐";
        MessageDigest instance = MessageDigest.getInstance("SHA-256");
        byte[] nameBytes = instance.digest(name.getBytes());
        System.out.println(Arrays.toString(nameBytes));

        String res = new String(nameBytes);
        System.out.println(res);

        // 十六进制展示
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<nameBytes.length;i++){
            int val = nameBytes[i] & 255;  // 负数转换为正数
            if (val<16){
                sb.append("0");
            }
            sb.append(Integer.toHexString(val));
        }
        String hexData = sb.toString();
        System.out.println(hexData); // e6ada6e6b29be9bd90
    }
}
```

```python
import hashlib

m = hashlib.sha256()
m.update("武沛齐".encode("utf-8"))
v1 = m.digest()
print(v1)
v2 = m.hexdigest()
print(v2)

```



### 3.10 aes加密

![image-20211012192408372](爬虫.assets/image-20211012192408372.png)

![image-20211012192555254](爬虫.assets/image-20211012192555254.png)

```java
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Base64;

public class Hello {

    public static void main(String[] args) throws Exception {
        String data = "武沛齐";
        String key = "fd6b639dbcff0c2a1b03b389ec763c4b";
        String iv = "77b07a672d57d64c";

        // 加密
        byte[] raw = key.getBytes();
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        IvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);
        byte[] encrypted = cipher.doFinal(data.getBytes());
        System.out.println(Arrays.toString(encrypted));
        
    }
}
```

```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

KEY = "fd6b639dbcff0c2a1b03b389ec763c4b"
IV = "77b07a672d57d64c"


def aes_encrypt(data_string):
    aes = AES.new(
        key=KEY.encode('utf-8'),
        mode=AES.MODE_CBC,
        iv=IV.encode('utf-8')
    )
    raw = pad(data_string.encode('utf-8'), 16)
    return aes.encrypt(raw)

data = aes_encrypt("武沛齐")
print(data)
print([ i for i in data])

```









### 3.11 gzip压缩

抖音注册设备：



```java
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.io.OutputStream;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

public class Hello {

    public static void main(String[] args) throws IOException {

        // 压缩
        String data = "武沛齐";
        // System.out.println(Arrays.toString(data.getBytes()));
        ByteArrayOutputStream v0_1 = new ByteArrayOutputStream();
        GZIPOutputStream v1 = new GZIPOutputStream((v0_1));
        v1.write(data.getBytes());
        v1.close();
        byte[] arg6 = v0_1.toByteArray();
        System.out.println(Arrays.toString(arg6));

        // 解压缩
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ByteArrayInputStream in = new ByteArrayInputStream(arg6);
        GZIPInputStream ungzip = new GZIPInputStream(in);
        byte[] buffer = new byte[256];
        int n;
        while ((n = ungzip.read(buffer)) >= 0) {
            out.write(buffer, 0, n);
        }
        byte[] res = out.toByteArray();
        // System.out.println(Arrays.toString(res));
        System.out.println(out.toString("UTF-8"));

    }
}
```

```python
import gzip


# 压缩
"""
s_in = "我是武沛齐".encode('utf-8')
s_out = gzip.compress(s_in)
print([i for i in s_out])
"""

# 解压缩
"""
res = gzip.decompress(s_out)
print(res)
print(res.decode('utf-8'))
"""
```



# 安卓开发

![image-20211013132450166](爬虫.assets/image-20211013132450166.png)

## 1. 环境搭建

### 1.1 JDK

在自己电脑上安装 JDK并设置环境变量。



接下来，我们就来下载和安装吧。

```
JDK8（jdk 1.8）版本（目前最新已到17）

官方地址：https://www.oracle.com/java/technologies/downloads/#java8
百度云盘：
```

安装好之后需要配置下环境变量。

![image-20210929163956511](爬虫.assets/image-20210929163956511-16539126663333.png)

![image-20211014023620873](爬虫.assets/image-20211014023620873.png)

如果先配置 JAVA_HOME的话，再在Path中配置时，只需要写：

```
%JAVA_HOME%\bin
```



### 1.2 Android Studio

Android Studio是安卓的继承开发环境。

https://developer.android.google.cn/studio/

下载之后，点击下一步去安装即可完成。



首次启动时会报错显示：

<img src="爬虫.assets/image-20211013205205729.png" alt="image-20211013205205729" style="zoom:33%;" />

这是因为，我们如果想要做安卓开发的话，还需要去安装 android SDK，而Android Studio没有检测到安装的SDK，所以报错了。

此处直接点击 【Cancel】即可，接下来我们会在Android Studio中去安装android SDK。

<img src="爬虫.assets/image-20211013205939540.png" alt="image-20211013205939540" style="zoom:33%;" />

<img src="爬虫.assets/image-20211014025615261.png" alt="image-20211014025615261" style="zoom:33%;" />

注意：此处一定要记住自己SDK安装目录。





<img src="爬虫.assets/image-20211013210017655.png" alt="image-20211013210017655" style="zoom:33%;" />



### 1.3 Android SDK环境变量

方便我们以后再命令行去执行安卓相关的命令。



![image-20211014030014477](爬虫.assets/image-20211014030014477.png)



![image-20211014030144731](爬虫.assets/image-20211014030144731.png)

![image-20211014030344458](爬虫.assets/image-20211014030344458.png)







### 1.4 创建项目

<img src="爬虫.assets/image-20211013210312240.png" alt="image-20211013210312240" style="zoom:33%;" />



<img src="爬虫.assets/image-20211013210345112.png" alt="image-20211013210345112" style="zoom: 33%;" />



<img src="爬虫.assets/image-20211013210529858.png" alt="image-20211013210529858" style="zoom:33%;" />



![image-20211014015233519](爬虫.assets/image-20211014015233519.png)



- .gradle 和 .idea，自动生成的隐藏文件。
- app，项目相关的代码和资源在这个目录。
- gradle，是一个构件工具，帮助我们自动寻找配置中的第三方包、依赖的版本、Java代码、资源并编译成APK。
  - gradle
  - build.gradle
  - gradel.properties
  - gradlew
  - gradlew.bat
  - settings.gradle 
- local.properties，本地属性（android sdk的安装路径）。
- .gitignore，是git版本控制时的忽略文件。



进入app里面

![image-20211014031536049](爬虫.assets/image-20211014031536049.png)

![image-20211014031644563](爬虫.assets/image-20211014031644563.png)



### 1.5 虚拟设备

![image-20211014031914360](爬虫.assets/image-20211014031914360.png)

![image-20211014031955060](爬虫.assets/image-20211014031955060.png)



当然，也可以去连接你 mumu模拟器 or  手机设备。







## 安卓开发

- 登录界面

- okhttp包，将请求发送到API接口。

  - okhttp，GET请求（路飞的API为例）

  - okhttp，POST请求（路飞API为例）+ Form【user=wupeiqi&pwd=123】

  - okhttp，POST请求 + JSON格式

    ```python
    data = {
        "username":"wupeiqi",
        "pwd":"123"
    }
    ```

    ```java
     new Thread() {
                @Override
                public void run() {
                    OkHttpClient client = new OkHttpClient();
    
                    // FormBody form = new FormBody.Builder().add("username","wupeiqi").add("password","123").build();
    
                    // JSONObject json = new JSONObject();
                    // json.put("username","wupeiqi");
                    // json.put("password","123");
    
                    JSONObject json = new JSONObject(dataMap);
                    String jsonString = json.toString();
                    RequestBody form = RequestBody.create(MediaType.parse("application/json;charset=utf-8"), jsonString);
    
                    Request request = new Request.Builder().url("https://api.luffycity.com/api/v1/auth/password/login/?loginWay=password").post(form).build();
                    Call call = client.newCall(request);
                    try {
                        Response response = call.execute(); // 发送请求
                        ResponseBody body = response.body();
                        String resString = body.string();
    
                        Log.i("登录界面--->", resString);
                        // 获取数据并处理
    
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }.start();
    ```



### 1.1 序列化 Gson

- 引入

  ```
  implementation 'com.google.code.gson:gson:2.8.6'
  ```

- 序列化

  ```java
  package com.nb.city;
  
  class HttpContext {
      public int code;
      public String message;
  
      public HttpContext(int code, String msg) {
          this.code = code;
          this.message = msg;
      }
  }
  
  HttpContext context = new HttpContext(1000,"成功");
  
  // 序列化成JSON字符串
  String jsonData = new Gson().toJson(context);
  ```

- 反序列化

  ```
  {
  	"origin":"110.248.149.62",
  	"url:"https://www.httpbin.org/post",
  	"dataList":[
  		{"id":1,"name":"武沛齐"},
  		{"id":1,"name":"武沛齐"}
  	]
  }
  ```

  ```python
  class Item{
      public int id;
      pubiic String name;
  }
  
  class HttpResponse{
      public String url;
  	public String origin;
  	public ArryList<Item> dataList;
  }
  
  
  
  
  String responseString = "{\"origin\": \"110.248.149.62\",\"url\": \"https://www.httpbin.org/post\",\"dataList\":[{\"id\":1,\"name\":\"武沛齐\"},{\"id\":2,\"name\":\"eric\"}]}";
  
  HttpResponse res = new Gson().fromJson(responseString, HttpResponse.class);
  res.url
  res.origin
  res.dataList
  ```



### 1.2 保存到xml中

登录

```
SharedPreferences sp = getSharedPreferences("sp_city", MODE_PRIVATE);
SharedPreferences.Editor editor = sp.edit();
editor.putString("token",res.token);
editor.commit();
```



注销

```java
SharedPreferences sp = getSharedPreferences("sp_city", MODE_PRIVATE);
SharedPreferences.Editor editor = sp.edit();
editor.remove("token");
editor.commit();
```



读取

```python
SharedPreferences sp = getSharedPreferences("sp_city", MODE_PRIVATE);
String token = sp.getString("token","");

```



注意：不仅还会存储一些，初始化设备ID（抖音cdid），手机中的数据清空（应用清楚所有数据）。



### 1.3 跳转

```
Intent in = new Intent(mContext, IndexActivity.class);
startActivity(in);
```



### 1.4 网络请求相关补充

#### 1.OKHttp

```java
new Thread() {
    @Override
    public void run() {
        OkHttpClient client = new OkHttpClient();

        JSONObject json = new JSONObject(dataMap);
        String jsonString = json.toString();
        RequestBody form = RequestBody.create(MediaType.parse("application/json;charset=utf-8"), jsonString);
        
        // 请求头中添加  x-gorgon="sdfkkkkjfsdfsdf"
        Request request = new Request.Builder().url("https://api.luffycity.com/api/v1/auth/password/login/?loginWay=password").post(form).build();
        Call call = client.newCall(request);
        try {
            Response response = call.execute(); // 发送请求
            ResponseBody body = response.body();
            String resString = body.string();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}.start();
```

#### 2.OKhttp拦截器

```java
// 4.发送请求拦截器
Interceptor interceptor = new Interceptor() {
    @NotNull
    @Override
    public Response intercept(@NotNull Chain chain) throws IOException {
        String sign = "sdfsdfsdf";
        // 请求还未发送，在请求体中增加了一个请求头
        Request request = chain.request().newBuilder().addHeader("x-gorgon", sign).build();
        Response response = chain.proceed(request);
        return response;
    }
};

new Thread() {
    @Override
    public void run() {
        OkHttpClient client = new OkHttpClient.Builder().addInterceptor(interceptor).build();

        // FormBody form = new FormBody.Builder().add("username","wupeiqi").add("password","123").build();

        // JSONObject json = new JSONObject();
        // json.put("username","wupeiqi");
        // json.put("password","123");

        JSONObject json = new JSONObject(dataMap);
        String jsonString = json.toString();
        RequestBody form = RequestBody.create(MediaType.parse("application/json;charset=utf-8"), jsonString);

        Request request = new Request.Builder().url("https://api.luffycity.com/api/v1/auth/password/login/?loginWay=password").post(form).build();
        Call call = client.newCall(request);
        try {
            Response response = call.execute(); // 发送请求
            ResponseBody body = response.body();
            String resString = body.string();

            // json字符串={"code":-1,"msg":"校验错误","data":{"global_error":["密码未设置，请使用短信登录"]}}
            // json反序列化，字符串转化转换成对象。
            // json.loads(json字符串)
            String responseString = "{\"token\": \"uuyffsdkfjumfdkjsdf\",\"url\": \"https://www.httpbin.org/post\",\"dataList\":[{\"id\":1,\"name\":\"武沛齐\"},{\"id\":2,\"name\":\"eric\"}]}";
            HttpResponse res = new Gson().fromJson(responseString, HttpResponse.class);
            Log.e("登录界面------->", res.toString());
            Log.i("登录界面--->", resString);
            //  HttpResponse{url='https://www.httpbin.org/post', origin='110.248.149.62', dataList=[Item{id=1, name='武沛齐'}, Item{id=2, name='eric'}]}

            // 保存起来：cookie、localstoreage
            // xml文件: data/data/com.nb.city
            // res.token
            SharedPreferences sp = getSharedPreferences("sp_city", MODE_PRIVATE);
            SharedPreferences.Editor editor = sp.edit();
            editor.putString("token", res.token);
            editor.commit();

            // 跳转首页
            Intent in = new Intent(mContext, IndexActivity.class);
            startActivity(in);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}.start();

```





### 1.5 网络请求retrofit

retrofit是在OKHttp请求的基础上又封装了一层，让我们发送请求时候就可以更加的简单。（B站）

- 配置

  ```
  // implementation "com.squareup.okhttp3:okhttp:4.9.1"
  implementation "com.squareup.retrofit2:retrofit:2.9.0"
  ```

- “接口”

  ```java
  package com.nb.luffy;
  
  import okhttp3.RequestBody;
  import okhttp3.ResponseBody;
  import retrofit2.Call;
  import retrofit2.http.Body;
  import retrofit2.http.Field;
  import retrofit2.http.FormUrlEncoded;
  import retrofit2.http.POST;
  import retrofit2.http.GET;
  import retrofit2.http.Query;
  
  public interface HttpRequest {
  
      @POST("/api/v1/post")
      @FormUrlEncoded
      Call<ResponseBody> postLogin(@Field("name") String userName, @Field("pwd") String password);
  
      @GET("/api/v2/xxx")
      Call<ResponseBody> getInfo(@Query("age") String age);
  
      @POST("/post")
      Call<ResponseBody> postLoginJson(@Body RequestBody body);
  
      @GET("/index")
      Call<ResponseBody> getIndex(@Query("age") String age);
  }
  
  ```

- 发送请求

  ```java
  new Thread() {
      @Override
      public void run() {
          Retrofit retrofit = new Retrofit.Builder().baseUrl("http://api.baidu.com/").build();
          HttpRequest httpRequest = retrofit.create(HttpRequest.class);
          Call<ResponseBody> call = httpRequest.login("wupeiqi","123123");
          try {
              ResponseBody responseBody = call.execute().body();
              String responseString = responseBody.string();
              Log.i("登录", responseString);
  
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }.start();
  ```

  ```
  http://api.baidu.com/api/v1/post
  n1=wupeiqi&n2=123123
  ```



提示：jadx打开B站：关键字：`x/report/andriod2`



### 总结

jadx、jeb去反编译安卓代码：

- 关键字搜索
- 根据请求的流程去逐步查找
- Java调用关系

注意：地方、小app一般了解上面的东西完全都可以给他逆向出来。





# JNI开发

什么是jni？

java native interface ，Java本地开发接口，实现JAVA和C语言之间的相互调用。

![image-20211019213052936](爬虫.assets/image-20211019213052936.png)

JNI存在的意义是什么呢？

- 【开发】一些系统底层功能Java无法直接调用，只能借助C、C++编程来实现。
- 【开发】对于一些性能要求比较高的功能，用C、C++更加高效。
- 【爬虫】将核心算法用C、C++ 增加逆向破解的难度。

对于我们来讲，需要了解安卓开发中如何用JNI进行开发，并实现Java和C代码的相互调用，更有利于你的分析和逆向app程序。



那么如何基于JNI来开发app程序呢？

ndk，native develop kits。本地开发工具包，用于JNI开发的工具包。

- 【之前】单独下载。

- 【现在】Andorid Studio

  ![image-20211018230948836](爬虫.assets/image-20211018230948836.png)





只要你安装好的NDK，就可以基于Andriod Studio进行JNI开发。

- 原来的安装项目开发【city】
  - Empty 模板
- 新建Andriod项目时，会用C去开发核心代码。【Navtive C++模板】
  - Navtive C++模板（Empty 模板 + C基本设置）



如果你想在java中结合JNI实现调用C代码。

- 项目中进行调用

  ```python
  int res = EncryptUtils.add(1,2);
  ```

- Java类，不需要实现具体的逻辑，只定义类和方法。

  ```java
  package com.nb.fucker;
  
  //com.nb.fucker.EncryptUtils
  class EncryptUtils {
  
      static {
          // 加载C语言的文件。
          System.loadLibrary("encrypt");
      }
  
      /*
      调用native方法实现数据相加
       */
      public static native int add(int v1, int v2);
  
      /*
      调用native方法实现字符串加密
       */
      public static native String sign(String origin);
  }
  
  ```

- C/C++，具体实现功能的函数。

  ```c
  // java_包名_类名称_方法名称
  // java_com_nb_fucker_EncryptUtils_add
  Java_com_nb_fucker_EncryptUtils_add(JNIEnv *env, jclass obj, jint v1, jint v2) {
      int base = 100;
      int result = base + v1 - v2;
      return result;
  }
  
  Java_com_nb_fucker_EncryptUtils_sign(JNIEnv *env, jclass obj, jstring origin) {
  
      char data[] = "ubffi19912ybbbc";
      data[0] = 'b';
  
      return (*env)->NewStringUTF(env, data);
  }
  ```

- 配置 CMakeLists.txt

  ```python
  add_library( # Sets the name of the library.
      encrypt
  
      # Sets the library as a shared library.
  
      SHARED
      # Provides a relative path to your source file(s).
  
      encrypt.c)
  
  target_link_libraries( # Specifies the target library.
          native-lib encrypt
  
          # Links the target library to the log library
          # included in the NDK.
          ${log-lib})
  ```







## 1. Native C++模板

在项目开发之处，如果知道项目肯定会用到JNI开发，那么在创建安卓项目时，可以选择 Native C++模板。

- 空安卓Activety
- 基本JNI配置。

<img src="爬虫.assets/image-20211018224711683.png" alt="image-20211018224711683" style="zoom:33%;" />

<img src="爬虫.assets/image-20211018224802094.png" alt="image-20211018224802094" style="zoom:33%;" />



<img src="爬虫.assets/image-20211018224823051.png" alt="image-20211018224823051" style="zoom:33%;" />

<img src="爬虫.assets/image-20211018224952802.png" alt="image-20211018224952802" style="zoom: 25%;" />



### 1.1 新建加密类

![image-20211018225656576](爬虫.assets/image-20211018225656576.png)



### 1.2 生成头文件

![image-20211018225815509](爬虫.assets/image-20211018225815509.png)



### 1.3 创建c文件

创建c文件，用于编写算法的底层实现（将头文件的内容拷贝过来，在他的基础上进行修改）。

![image-20211018230204492](爬虫.assets/image-20211018230204492.png)



提示：删除上一步生成的头文件。

### 1.4 配置

![image-20211018230425090](爬虫.assets/image-20211018230425090.png)





### 1.5 同步

![image-20211018230458959](爬虫.assets/image-20211018230458959.png)



同步，程序不再报错，接下来就需要补充代码并基于C实现具体的算法。

注意：如果无法同步，则需要在项目中安装NDK。

![image-20211018230923050](爬虫.assets/image-20211018230923050.png)

![image-20211018230948836](爬虫.assets/image-20211018230948836.png)





### 1.6 算法实现

![image-20211018230651832](爬虫.assets/image-20211018230651832.png)

![image-20211018234545440](爬虫.assets/image-20211018234545440.png)





### 1.7 运行并调用

![image-20211018234848437](爬虫.assets/image-20211018234848437.png)

![image-20211018234625270](爬虫.assets/image-20211018234625270.png)





## 价值

逆向别人网站的so文件时，知道他们文件名之间的对应关系。

告诉一个不幸的消息，定位到到我的C函数太简单了。







## 2.动态注册

上述示例是基于静态注册，即使：

```
	 Java中的包名称					  				C中定义的方法名称
com.nb.fucker.EncryptUtils				Java_com_nb_fucker_EncryptUtils_add
```

![image-20211018235023761](爬虫.assets/image-20211018235023761.png)



动态注册的步骤：

- 调用

  ```python
  int v1 = DynamicUtils.add(1,2)
  ```

  

- Java的类

  ```java
  package com.nb.fucker;
  
  class DynamicUtils {
      static {
          System.loadLibrary("dynamic");
      }
  
      public static native int add(int v1, int v2);
  }
  ```

- C函数

  ```c
  jint plus(JNIEnv *env, jobject obj, jint v1, jint v2) {
      return v1 + v2;
  }
  
  
  static JNINativeMethod gMethods[] = {
          //Java函数             C语言中的函数
          {"add", "(II)I", (void *) plus},
  };
  
  JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
      JNIEnv *env = NULL;
      // 在java虚拟机中获取 env
      if ((*vm)->GetEnv(vm, (void **) &env, JNI_VERSION_1_6) != JNI_OK) {
          return JNI_ERR;
      }
      
      // 找到Java中的类，env=JNI
      jclass clazz = (*env)->FindClass(env, "com/nb/fucker/DynamicUtils");
  
      // 将类中的方法注册到JNI中
      int res = (*env)->RegisterNatives(env, clazz, gMethods, 1);
      
      if (res < 0) {
          return JNI_ERR;
      }
      return JNI_VERSION_1_6;
  }
  ```

- 配置 CMakeLists.txt

  ```
  ...
  ```

  

## 价值

分析动态注册流程。















































































































